Description: Latest changes from upstream git

 Generated using 'git diff v1.2.0 master'.

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..9d52920
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,56 @@
+# vim: sw=2
+
+name: Build CI
+
+on:
+  push:
+  pull_request:
+  release:
+    types: [published]
+  check_suite:
+    types: [rerequested]
+
+jobs:
+
+  build:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        image: ["debian:bullseye", "debian:bookworm", "debian:sid"]
+    container:
+      image: ${{ matrix.image }}
+      options: --cpus=2
+    steps:
+    - name: Dump GitHub context
+      env:
+        GITHUB_CONTEXT: ${{ toJson(github) }}
+      run: echo "$GITHUB_CONTEXT"
+
+    - name: Install pre-dependencies
+      env:
+        DEBIAN_FRONTEND: noninteractive
+      run: |
+        set -e
+        set -x
+        apt --quiet update
+        # Install stuff needed to check out the linuxcnc repo and turn it into a debian source package.
+        apt --yes --quiet install --no-install-suggests eatmydata
+        eatmydata apt --yes --quiet install --no-install-suggests git devscripts
+
+    - uses: actions/checkout@v3
+      with:
+        # "fetch-depth: 0" fetches all of history, this is needed by
+        # our build system to determine the version from tags
+        fetch-depth: 0
+
+    - name: Build source
+      env:
+        DEBIAN_FRONTEND: noninteractive
+      run: |
+        set -e
+        set -x
+        #eatmydata apt --yes --quiet build-dep --indep-only .
+        eatmydata apt --yes --quiet install cmake libxml2-dev qtbase5-dev
+        mkdir builddir && cd builddir
+        eatmydata cmake -DBUILD_GUI=1 ..
+        eatmydata make
diff --git a/.gitignore b/.gitignore
index 554dde4..2d2238c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
-build/
+build*/
+.vscode/
 sample.pro.user
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 03e7fd3..e1843c1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,3 +1,24 @@
+#*******************************************************************************
+# libonvif/CMakeLists.txt
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
 cmake_minimum_required(VERSION 3.17)
 
 project(libonvif)
@@ -5,6 +26,15 @@ project(libonvif)
 set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED True)
 
+if(MSVC)
+    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS TRUE)
+    set(BUILD_SHARED_LIBS TRUE)
+endif()
+
+include(GNUInstallDirs)
+# set arch-specific include dir
+set(CMAKE_INSTALL_INCLUDEDIR "include/${CMAKE_LIBRARY_ARCHITECTURE}")
+
 find_package(LibXml2)
 if (NOT LibXml2_FOUND)
     message("-- Looking for conda installation of libxml2")
@@ -41,38 +71,135 @@ target_include_directories(onvif_static PUBLIC
     $ENV{CONDA_PREFIX}/Library/include
 )
 
-add_library(onvif SHARED
+add_library(onvif_shared SHARED
     src/onvif.c
     src/cencode.c
     src/sha1.c
 )
 
-target_link_libraries(onvif PRIVATE
+set_target_properties(onvif_shared PROPERTIES
+    OUTPUT_NAME onvif
+    ARCHIVE_OUTPUT_DIRECTORY onvif_shared
+)
+
+target_link_libraries(onvif_shared PRIVATE
     ${LIBXML2_LIBRARIES}
 )
 
-target_include_directories(onvif PUBLIC
+set_target_properties(onvif_shared PROPERTIES
+    SOVERSION 0
+)
+
+target_include_directories(onvif_shared PUBLIC
     include
     ${LIBXML2_INCLUDE_DIRS}
     $ENV{CONDA_PREFIX}/Library/include
 )
 
-add_executable(discover
-    example/discover.c
+add_executable(onvif-discover
+    example/onvif-discover.c
+)
+
+target_link_libraries(onvif-discover PRIVATE
+    onvif_shared
+    ${LIBXML2_LIBRARIES}
 )
 
-target_link_libraries(discover PRIVATE
+target_include_directories(onvif-discover PUBLIC
+    include
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+add_executable(onvif-getall
+    example/onvif-getall.c
+)
+
+target_link_libraries(onvif-getall PRIVATE
     onvif_static
     ${LIBXML2_LIBRARIES}
 )
 
-target_include_directories(discover PUBLIC
+target_include_directories(onvif-getall PUBLIC
+    include
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+add_executable(onvif-time
+    example/onvif-time.c
+)
+
+target_link_libraries(onvif-time PRIVATE
+    onvif_shared
+    ${LIBXML2_LIBRARIES}
+)
+
+target_include_directories(onvif-time PUBLIC
     include
     ${LIBXML2_INCLUDE_DIRS}
 )
 
+add_executable(onvif-util
+    example/onvif-util.cpp
+)
+
+target_link_libraries(onvif-util PRIVATE
+    onvif_shared
+    ${LIBXML2_LIBRARIES}
+)
+
+target_include_directories(onvif-util PUBLIC
+    include
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+if (BUILD_GUI)
+    set(CMAKE_AUTOMOC ON)
+    set(CMAKE_AUTORCC ON)
+    set(CMAKE_AUTOUIC ON)
+    find_package(Qt5 COMPONENTS Widgets REQUIRED)
+
+    add_executable(onvif_exe
+        sample/admintab.cpp
+        sample/camera.cpp
+        sample/cameradialogtab.cpp
+        sample/cameralistmodel.cpp
+        sample/cameralistview.cpp
+        sample/camerapanel.cpp
+        sample/configtab.cpp
+        sample/discovery.cpp
+        sample/imagetab.cpp
+        sample/logindialog.cpp
+        sample/main.cpp
+        sample/mainwindow.cpp
+        sample/networktab.cpp
+        sample/onvifmanager.cpp
+        sample/ptztab.cpp
+        sample/videotab.cpp
+    )
+
+    set_target_properties(onvif_exe PROPERTIES
+        OUTPUT_NAME onvif
+        ARCHIVE_OUTPUT_DIRECTORY onvif_exe
+    )
+
+    target_link_libraries(onvif_exe PRIVATE
+        Qt5::Widgets
+        onvif_static
+        ${LIBXML2_LIBRARIES}
+    )
+
+    target_include_directories(onvif_exe PUBLIC
+        include
+        ${LIBXML2_INCLUDE_DIRS}
+    )
+
+    install(TARGETS onvif_exe DESTINATION bin)
+endif()
 
-install(TARGETS onvif DESTINATION bin)
-install(TARGETS discover DESTINATION bin)
-install(TARGETS onvif_static DESTINATION lib)
-install(FILES include/onvif.h DESTINATION include)
\ No newline at end of file
+install(TARGETS onvif-discover DESTINATION bin)
+install(TARGETS onvif-getall DESTINATION bin)
+install(TARGETS onvif-time DESTINATION bin)
+install(TARGETS onvif-util DESTINATION bin)
+install(TARGETS onvif_shared DESTINATION "${CMAKE_INSTALL_LIBDIR}/")
+install(TARGETS onvif_static DESTINATION "${CMAKE_INSTALL_LIBDIR}/")
+install(FILES include/onvif.h DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
diff --git a/README.md b/README.md
index 3ad5623..fe2f734 100644
--- a/README.md
+++ b/README.md
@@ -17,17 +17,27 @@ An example program is included with libonvif that will discover compatible
 cameras on the local network and query each of them for their RSTP connection
 uri information.
 
+Additionally, there is a comprehensive GUI sample program that includes the
+discovery functionality as well controls for adjusting camera parameters and
+PTZ operations.  The GUI sample is written in Qt and can be compiled with
+either cmake or qmake using Qt Creator.
+
 Quick Install With Anaconda
 ---------------------------
 
 The pre built version of the library can be installed with anaconda using the
 command shown below.  The library installation includes the discover program
-which can be used to find the IP addresses of cameras on the network.
+which can be used to find the IP addresses of cameras on the network.  It also
+includes the gui interface.
 
 ```bash
 conda install -c conda-forge -c sr99622 libonvif
 ```
 
+The discovery program is invoked using the 'onvif-discovery' command.
+
+The gui interface may be invoked using the 'onvif' command.
+
 To Install From Source
 ----------------------
 
@@ -129,7 +139,7 @@ make
 Run the test program on Linux
 
 ```bash
-./discover
+./onvif-discover
 ```
 
 Windows instructions for compiling the test program
@@ -145,7 +155,7 @@ cmake --build . --config Release
 Run the test program on Windows
 
 ```bash
-Release\discover
+Release\onvif-discover
 ```
 
 
diff --git a/cmake/FindLibOnvif.cmake b/cmake/FindLibOnvif.cmake
index 9970978..7633f89 100644
--- a/cmake/FindLibOnvif.cmake
+++ b/cmake/FindLibOnvif.cmake
@@ -1,3 +1,24 @@
+#*******************************************************************************
+# FindLibOnvif.cmake
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
 set(win_path "C:/Program Files (x86)")
 
 find_path(LIBONVIF_INCLUDE_DIR onvif.h
diff --git a/example/CMakeLists.txt b/example/CMakeLists.txt
index c1f6dee..d3b6fe1 100644
--- a/example/CMakeLists.txt
+++ b/example/CMakeLists.txt
@@ -1,3 +1,24 @@
+#*******************************************************************************
+# libonvif/example/CmakeLists.txt
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
 cmake_minimum_required(VERSION 3.17)
 set(win_path "C:/Program Files (x86)")
 
@@ -9,7 +30,7 @@ if (UNIX)
     set(xml_lib_name "xml2")
 endif()
 
-project(discover)
+project(onvif-discover)
 
 set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED True)
@@ -39,16 +60,58 @@ if (LibOnvif_FOUND)
     message("-- Found LIBONVIF_LIBRARIES ${LIBONVIF_LIBRARIES}")
 endif()
 
-add_executable(discover
-    discover.c
+add_executable(onvif-discover
+    onvif-discover.c
+)
+
+target_link_libraries(onvif-discover PRIVATE
+    ${LIBONVIF_LIBRARIES}
+    ${LIBXML2_LIBRARIES}
+)
+
+target_include_directories(onvif-discover PUBLIC
+    ${LIBONVIF_INCLUDE_DIRS}
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+add_executable(onvif-getall
+    onvif-getall.c
+)
+
+target_link_libraries(onvif-getall PRIVATE
+    ${LIBONVIF_LIBRARIES}
+    ${LIBXML2_LIBRARIES}
+)
+
+target_include_directories(onvif-getall PUBLIC
+    ${LIBONVIF_INCLUDE_DIRS}
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+add_executable(onvif-time
+    onvif-time.c
+)
+
+target_link_libraries(onvif-time PRIVATE
+    ${LIBONVIF_LIBRARIES}
+    ${LIBXML2_LIBRARIES}
+)
+
+target_include_directories(onvif-time PUBLIC
+    ${LIBONVIF_INCLUDE_DIRS}
+    ${LIBXML2_INCLUDE_DIRS}
+)
+
+add_executable(onvif-util
+    onvif-util.cpp
 )
 
-target_link_libraries(discover PRIVATE
+target_link_libraries(onvif-util PRIVATE
     ${LIBONVIF_LIBRARIES}
     ${LIBXML2_LIBRARIES}
 )
 
-target_include_directories(discover PUBLIC
+target_include_directories(onvif-util PUBLIC
     ${LIBONVIF_INCLUDE_DIRS}
     ${LIBXML2_INCLUDE_DIRS}
 )
diff --git a/example/discover.c b/example/discover.c
deleted file mode 100644
index f32e603..0000000
--- a/example/discover.c
+++ /dev/null
@@ -1,38 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <onvif.h>
-
-int number_of_cameras;
-
-int main ( int argc, char **argv )
-{
-    struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
-    struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
-    initializeSession(onvif_session);
-    number_of_cameras = broadcast(onvif_session);
-    fprintf(stdout, "libonvif found %d cameras\n", number_of_cameras);
-
-    for (int i = 0; i < number_of_cameras; i++) {
-        prepareOnvifData(i, onvif_session, onvif_data);
-
-        fprintf(stdout, "%s\n", onvif_data->camera_name);
-        fprintf(stdout, "enter username:");
-        fgets(onvif_data->username, 128, stdin);
-        fprintf(stdout, "enter password:");
-        fgets(onvif_data->password, 128, stdin);
-
-        onvif_data->username[strcspn(onvif_data->username, "\r\n")] = 0;
-        onvif_data->password[strcspn(onvif_data->password, "\r\n")] = 0;
-
-        if (fillRTSP(onvif_data) == 0)
-            fprintf(stdout, "%s\n", onvif_data->stream_uri);
-        else
-            fprintf(stderr, "Error getting camera uri - %s\n", onvif_data->last_error);
-
-    }
-
-    closeSession(onvif_session);
-    free(onvif_session);
-    free(onvif_data);
-    return 0;
-}
diff --git a/example/onvif-discover.c b/example/onvif-discover.c
new file mode 100644
index 0000000..ecd7453
--- /dev/null
+++ b/example/onvif-discover.c
@@ -0,0 +1,154 @@
+/*******************************************************************************
+* onvif-discover.c
+*
+* Copyright (c) 2020 Stephen Rhodes 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <onvif.h>
+
+int number_of_cameras;
+
+int main ( int argc, char **argv )
+{
+    struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
+    struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
+    initializeSession(onvif_session);
+    number_of_cameras = broadcast(onvif_session);
+    fprintf(stdout, "libonvif found %d cameras\n", number_of_cameras);
+
+    for (int i = 0; i < number_of_cameras; i++) {
+        prepareOnvifData(i, onvif_session, onvif_data);
+
+        fprintf(stdout, "%s [%s]\n", onvif_data->camera_name, onvif_data->xaddrs);
+        fprintf(stdout, "enter username:");
+        fgets(onvif_data->username, 128, stdin);
+        fprintf(stdout, "enter password:");
+        fgets(onvif_data->password, 128, stdin);
+
+        onvif_data->username[strcspn(onvif_data->username, "\r\n")] = 0;
+        onvif_data->password[strcspn(onvif_data->password, "\r\n")] = 0;
+
+        getDeviceInformation(onvif_data);
+        fprintf(stdout, "* Camera %d '%s' S/N:%s\n", i, onvif_data->camera_name, onvif_data->serial_number);
+
+        getTimeOffset(onvif_data);
+        fprintf(stdout, "Time offset %ld seconds, timezone is '%s', is%s dst, time %s\n",
+                onvif_data->time_offset,
+                onvif_data->timezone,
+                onvif_data->dst?"":" not",
+                onvif_data->datetimetype == 'M'?"set Manually":onvif_data->datetimetype == 'N'?"set via NTP":"setting unknown");
+
+        int index = 0;
+        while (true) {
+            if (fillRTSPn(onvif_data,index) == 0) {
+                fprintf(stdout, "* Profile %d\n%s\n", index, onvif_data->stream_uri);
+            } else {
+                if (index == 0)
+                    fprintf(stderr, "Error getting camera uri - %s\n", onvif_data->last_error);
+                break;
+			}
+            index++;
+
+            fprintf(stdout, "event_service: %s",onvif_data->event_service);
+            fprintf(stdout, "imaging_service: %s",onvif_data->imaging_service);
+            fprintf(stdout, "media_service: %s",onvif_data->imaging_service);
+            fprintf(stdout, "ptz_service: %s",onvif_data->imaging_service);
+            if (getProfile(onvif_data) == 0) {
+                fprintf(stdout, "Width: %d\n",onvif_data->width);
+                fprintf(stdout, "Height: %d\n",onvif_data->height);
+                fprintf(stdout, "FrameRateLimit: %d\n",onvif_data->frame_rate);
+                fprintf(stdout, "BitrateLimit: %d\n",onvif_data->bitrate);
+                fprintf(stdout, "GovLength: %d\n",onvif_data->gov_length);
+            } else {
+                fprintf(stderr, "Error getting profile - %s\n", onvif_data->last_error);
+                continue;
+            }
+
+            if (getOptions(onvif_data) == 0) {
+                fprintf(stdout, "Brightness:Min: %d\n",onvif_data->brightness_min);
+                fprintf(stdout, "Brightness:Max: %d\n",onvif_data->brightness_max);
+                fprintf(stdout, "ColorSaturation:Min: %d\n",onvif_data->saturation_min);
+                fprintf(stdout, "ColorSaturation:Max: %d\n",onvif_data->saturation_max);
+                fprintf(stdout, "Contrast:Min: %d\n",onvif_data->contrast_min);
+                fprintf(stdout, "Contrast:Max: %d\n",onvif_data->contrast_max);
+                fprintf(stdout, "Sharpness:Min: %d\n",onvif_data->sharpness_min);
+                fprintf(stdout, "Sharpness:Max: %d\n",onvif_data->sharpness_max);
+            } else {
+                fprintf(stderr, "Error getting options - %s\n", onvif_data->last_error);
+                continue;
+            }
+
+            if (getVideoEncoderConfigurationOptions(onvif_data) == 0) {
+                 /* onvif_data->resolutions_buf[16][128] */
+                int i;
+                fputs("Resolutions: ", stdout);
+                for (i = 0; i < 16; i++) {
+                    if (onvif_data->resolutions_buf[i][0]) {
+                        if (i > 0)
+                            fputs(", ", stdout);
+                        fputs(onvif_data->resolutions_buf[i], stdout);
+                    }
+                }
+                fprintf(stdout, "\n");
+
+                fprintf(stdout, "H264:GovLengthRange:Min: %d\n",onvif_data->gov_length_min);
+                fprintf(stdout, "H264:GovLengthRange:Max: %d\n",onvif_data->gov_length_max);
+                fprintf(stdout, "H264:FrameRateRange:Min: %d\n",onvif_data->frame_rate_min);
+                fprintf(stdout, "H264:FrameRateRange:Max: %d\n",onvif_data->frame_rate_max);
+                fprintf(stdout, "H264:BitRateRange:Min: %d\n",onvif_data->bitrate_min);
+                fprintf(stdout, "H264:BitRateRange:Max: %d\n",onvif_data->bitrate_max);
+            } else {
+                fprintf(stderr, "Error getting video encoder configuration options - %s\n", onvif_data->last_error);
+                continue;
+            }
+
+            if (getVideoEncoderConfiguration(onvif_data) == 0) {
+                fprintf(stdout, "Configuration:Name: %s\n",onvif_data->video_encoder_name_buf);
+                fprintf(stdout, "Configuration:UseCount: %d\n",onvif_data->use_count);
+                fprintf(stdout, "Configuration:GuaranteedFrameRate: %s\n",onvif_data->guaranteed_frame_rate?"true":"false");
+                fprintf(stdout, "Configuration:Encoding: %s\n",onvif_data->encoding);
+                fprintf(stdout, "Configuration:Resolution:Width: %d\n",onvif_data->conf_width);
+                fprintf(stdout, "Configuration:Resolution:Height: %d\n",onvif_data->conf_height);
+                fprintf(stdout, "Configuration:Quality: %f\n",onvif_data->quality);
+                fprintf(stdout, "Configuration:RateControl:FrameRateLimit: %d\n",onvif_data->conf_frame_rate_limit);
+                fprintf(stdout, "Configuration:RateControl:EncodingInterval: %d\n",onvif_data->conf_encoding_interval);
+                fprintf(stdout, "Configuration:RateControl:BitrateLimit: %d\n",onvif_data->conf_bitrate_limit);
+                fprintf(stdout, "Configuration:H264Profile: %s\n",onvif_data->h264_profile_buf);
+                fprintf(stdout, "Configuration:Multicast:AddressType: %s\n",onvif_data->multicast_address_type_buf);
+				if (strcmp(onvif_data->multicast_address_type_buf,"IPv6") == 0)
+                    fprintf(stdout, "Configuration:Multicast:IPv6Address: %s\n",onvif_data->multicast_address_buf);
+				else
+                    fprintf(stdout, "Configuration:Multicast:IPv4Address: %s\n",onvif_data->multicast_address_buf);
+                fprintf(stdout, "Configuration:Multicast:Port: %d\n",onvif_data->multicast_port);
+                fprintf(stdout, "Configuration:Multicast:TTL: %d\n",onvif_data->multicast_ttl);
+                fprintf(stdout, "Configuration:Multicast:AutoStart: %s\n",onvif_data->autostart?"true":"false");
+                fprintf(stdout, "Configuration:SessionTimeout: %s\n",onvif_data->session_time_out_buf);
+            } else {
+                fprintf(stderr, "Error getting video encoder configuration - %s\n", onvif_data->last_error);
+                continue;
+            }
+        }
+    }
+
+    closeSession(onvif_session);
+    free(onvif_session);
+    free(onvif_data);
+    return 0;
+}
diff --git a/example/onvif-getall.c b/example/onvif-getall.c
new file mode 100644
index 0000000..e46374f
--- /dev/null
+++ b/example/onvif-getall.c
@@ -0,0 +1,62 @@
+/*******************************************************************************
+* onvif-getall.c
+*
+* Copyright (c) 2022 Stephen Rhodes 
+* Originally authored by Brian D Scott
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "onvif.h"
+
+#define DEFAULT_USERNAME    "admin"
+#define DEFAULT_PASSWORD    "admin"
+
+void get_info(const char *host, const char *username, const char *password)
+{
+    struct OnvifData *onvif_data = (struct OnvifData *) calloc(1, sizeof (struct OnvifData));
+
+    sprintf(onvif_data->xaddrs, "http://%s/onvif/device_service", host);
+    strcpy(onvif_data->device_service, "POST /onvif/device_service HTTP/1.1\r\n");
+
+    /* Store username and password */
+    strncpy(onvif_data->username, username, sizeof (onvif_data->username) - 1);
+    strncpy(onvif_data->password, password, sizeof (onvif_data->password) - 1);
+
+    dumpConfigAll (onvif_data);
+
+    free(onvif_data);
+}
+
+int main(int argc, char **argv)
+{
+    const char *host;
+    const char *username;
+    const char *password;
+
+    if (argc <= 1) {
+        fprintf(stderr, "Usage: %s HOST[:PORT] [USERNAME] [PASSWORD]\n", argv[0]);
+        exit(1);
+    }
+
+    host = argv[1];
+    username = (argc > 2) ? argv[2] : DEFAULT_USERNAME;
+    password = (argc > 3) ? argv[3] : DEFAULT_PASSWORD;
+
+    get_info(host, username, password);
+}
diff --git a/example/onvif-time.c b/example/onvif-time.c
new file mode 100644
index 0000000..6629e7c
--- /dev/null
+++ b/example/onvif-time.c
@@ -0,0 +1,175 @@
+/*******************************************************************************
+* onvif-time.c
+*
+* Copyright (c) 2022 Stephen Rhodes 
+* Originally authored by Brian D Scott
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "onvif.h"
+#ifdef _WIN32
+#include "getopt-win.h"
+#else
+#include <getopt.h>
+#endif
+
+#define DEFAULT_USERNAME    "admin"
+#define DEFAULT_PASSWORD    "admin"
+
+static struct option longopts[] = {
+             { "user",      required_argument,	NULL,   'u'},
+             { "password",  required_argument,	NULL,   'p'},
+             { "all",       no_argument,        NULL,   'a'},
+             { "set",       no_argument,        NULL,   's'},
+             { "local",     no_argument,        NULL,   'l'},
+             { "ntp",       required_argument,  NULL,   'n'},
+             { "manual",    required_argument,  NULL,   'm'},
+             { NULL,        0,                  NULL,    0 }
+     };
+
+static const char *username = DEFAULT_USERNAME;
+static const char *password = DEFAULT_PASSWORD;
+static int all = 0;
+static int set = 0;
+static int local = 0;
+static const char *ntp = NULL;
+static int setNtp = 0;
+static int setManual = 0;
+
+static void processOne(struct OnvifData *onvif_data);
+
+int main(int argc, char **argv)
+{
+	int ch;
+	struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
+    struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
+	char *arg0 = argv[0];
+
+	while ((ch = getopt_long(argc, argv, "u:p:asln:m", longopts, NULL)) != -1) {
+		switch (ch) {
+            case 'u':
+				username = optarg;
+				break;
+			case 'p':
+				password = optarg;
+				break;
+			case 'a':
+				all = 1;
+				break;
+			case 's':
+				set = 1;
+				break;
+			case 'l':
+				local = 1;
+				set = 1;
+				break;
+			case 'n':
+				ntp = optarg;
+				setNtp = 1;
+				setManual = 0;
+				set = 1;
+				break;
+			case 'm':
+				setManual = 1;
+				setNtp = 0;
+				set = 1;
+				break;
+			case 0:
+				break;
+			default:
+				exit(1);
+		}
+	}
+	argc -= optind;
+    argv += optind;
+
+    if (!all && argc < 1) {
+        fprintf(stderr, "Usage: %s <options> [HOST ..]\n", arg0);
+        exit(1);
+    } else if (all && argc > 0) {
+        fprintf(stderr, "Usage: %s <options> [HOST ..]\n", arg0);
+        exit(1);
+	}
+    initializeSession(onvif_session);
+    int n = broadcast(onvif_session);
+
+	if (all && n == 0) {
+		fprintf(stderr,"No cameras on this network\n");
+		exit(1);
+	}
+
+	if (all) {
+		for (int i = 0; i < n; i++) {
+			prepareOnvifData(i, onvif_session, onvif_data);
+			processOne(onvif_data);
+		}
+	} else {
+		while (argc--) {
+			char *wanted = argv++[0];
+			int found = 0;
+			for (int i = 0; i < n; i++) {
+				prepareOnvifData(i, onvif_session, onvif_data);
+				char host[128];
+				extractHost(onvif_data->xaddrs, host);
+				if (strcmp(host,wanted) == 0) {
+					found = 1;
+					break;
+				}
+			}
+			if (found) {
+				processOne(onvif_data);
+			} else {
+				fprintf(stderr,"Camera at %s not found\n",wanted);
+			}
+		}
+	}
+}
+
+static void processOne(struct OnvifData *onvif_data) {
+	char host[128];
+	extractHost(onvif_data->xaddrs, host);
+	getHostname(onvif_data);
+	printf("%s(%s): Time offset %ld seconds. Timezone '%s'.%s%s\n",host,
+		onvif_data->host_name,
+		onvif_data->time_offset,
+		onvif_data->timezone,
+		onvif_data->dst ? " Dst." : "",
+		onvif_data->datetimetype == 'M'?" Manual time set.":onvif_data->datetimetype == 'N'?" NTP time set.":"");
+	if (setNtp) {
+		strcpy(onvif_data->ntp_addr,ntp);
+		onvif_data->ntp_dhcp = false;
+		if (!onvif_data->ntp_addr[0])
+			onvif_data->ntp_dhcp = true;
+		/* Decide if we have an IPv4 address, IPv6 address or dns name */
+		strcpy(onvif_data->ntp_type,"IPv4");
+		if (setNTP(onvif_data) < 0)
+			fprintf(stderr,"SetNTP: error %s\n",onvif_data->last_error);
+		onvif_data->datetimetype = 'N';
+	}
+	if (setManual)
+		onvif_data->datetimetype = 'M';
+	if (local)
+		onvif_data->timezone[0] = '\0';
+	if (set) {
+		if (setSystemDateAndTime(onvif_data) < 0)
+			fprintf(stderr,"SetSystemDateAndTime: error %s\n",onvif_data->last_error);
+		getTimeOffset(onvif_data);
+		printf("\tOffset now %ld\n",onvif_data->time_offset);
+	}
+}
\ No newline at end of file
diff --git a/example/onvif-util.cpp b/example/onvif-util.cpp
new file mode 100644
index 0000000..7783e2b
--- /dev/null
+++ b/example/onvif-util.cpp
@@ -0,0 +1,702 @@
+/*******************************************************************************
+* onvif-util.c
+*
+* Copyright (c) 2022 Stephen Rhodes 
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <iostream>
+#include <sstream>
+#include <vector>
+#include <string>
+#include <sstream>
+#include <stdio.h>
+#include <string.h>
+#include "onvif.h"
+#ifdef _WIN32
+#include "getopt-win.h"
+#else
+#include <getopt.h>
+#endif
+
+int longopt = 0;
+
+static struct option longopts[] = {
+             { "user",       required_argument, NULL,      'u'},
+             { "password",   required_argument, NULL,      'p'},
+             { "all",        no_argument,       NULL,      'a'},
+             { "help",       required_argument, NULL,      'h'},
+             { NULL,         0,                 NULL,       0 }
+     };
+
+static const char *username;
+static const char *password;
+
+static void showAll()
+{
+	std::cout << "Looking for cameras on the network..." << std::endl;
+	struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
+    struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
+	initializeSession(onvif_session);
+	int n = broadcast(onvif_session);
+	std::cout << "Found " << n << " cameras" << std::endl;
+	for (int i = 0; i < n; i++) {
+		prepareOnvifData(i, onvif_session, onvif_data);
+		char host[128];
+		extractHost(onvif_data->xaddrs, host);
+		getHostname(onvif_data);
+		printf("%s %s(%s)\n",host,
+			onvif_data->host_name,
+			onvif_data->camera_name);
+	}
+	closeSession(onvif_session);
+	free(onvif_session);
+	free(onvif_data);
+}
+
+static void showHelp()
+{
+	std::cout << "\n  onvif-util help\n\n"
+			  << "  To view all cameras on the network:\n"
+			  << "  onvif-util -a\n\n"
+			  << "  To login to a particular camera:\n"
+			  << "  onvif-util -u username -p password ip_address\n\n"
+			  << "  Once logged into the camera you can view data using the 'get' command followed by the data requested\n"
+			  << "  The (n) indicates an optional profile index to apply the setting, otherwise the current profile is used\n\n"
+			  << "    Data Retrieval Commands (start with get)\n\n"
+			  << "      get rtsp 'pass'(optional) (n)\n"
+			  << "      get capabilities\n"
+			  << "      get time\n"
+			  << "      get profiles\n"
+			  << "      get profile (n)\n"
+			  << "      get video (n)\n"
+			  << "      get video options (n)\n"
+			  << "      get imaging\n"
+			  << "      get imaging options\n"
+			  << "      get network\n\n"
+			  << "    Parameter Setting Commands (start with set)\n\n"
+			  << "      set resolution (n) - Resolution setting in the format widthxheight, must match the video option\n"
+			  << "      set framerate (n)\n"
+			  << "      set gov_length (n)\n"
+			  << "      set bitrate (n)\n"
+			  << "      set bightness value(required)\n"
+			  << "      set contrast value(required)\n"
+			  << "      set saturation value(required)\n"
+			  << "      set sharpness value(required)\n"
+			  << "      set ip_address value(required)\n"
+			  << "      set default_gateway value(required)\n"
+			  << "      set dns value(required)\n"
+			  << "      set dhcp value(required) - Accepted settings are 'on' and off'\n"
+			  << "      set password  value(required)\n\n"
+			  << "    Maintenance Commands\n\n"
+			  << "      help\n"
+			  << "      view (n) - View the camera output using ffplay (this assmumes you have ffplay installed in the path\n"
+			  << "      view player (n) - View the camera output with user specified player e.g. view vlc\n"
+			  << "      sync_time 'zone'(optional) - Sync the camera time to the computer.  Optionally adjusts based on camera time zone\n"
+			  << "      reboot\n\n"
+			  << "    To Exit Camera Session\n\n"
+			  << "      quit\n"
+	          << std::endl;
+}
+
+const std::string cat(const char* arg1, const char* arg2)
+{
+	std::string result(arg1);
+	result += arg2;
+	return result;
+}
+
+std::string uri_with_pass(OnvifData* onvif_data)
+{
+	std::string uri(onvif_data->stream_uri);
+	std::stringstream ss;
+	ss << uri.substr(0, 7) << onvif_data->username << ":" << onvif_data->password << "@" << uri.substr(7);
+	return ss.str();
+}
+
+void show(const std::vector<std::string>& args)
+{
+	std::cout << "args size: " << args.size() << std::endl;
+	for (int i = 0; i < args.size(); i++) {
+		std::cout << "args[" << i << "] = " << args[i] << std::endl;
+	}
+}
+
+void profileCheck(OnvifData* onvif_data, const std::vector<std::string>& args)
+{
+	int index = 0;
+	if (args.size() > 1) {
+		index = std::stoi(args[1]);
+		if (getProfileToken(onvif_data, index)) throw std::runtime_error(cat("get profile token - ", onvif_data->last_error));
+		if (strlen(onvif_data->profileToken) == 0) throw std::runtime_error(cat("invalid profile token - ", (char*)std::to_string(index).c_str()).data());
+		std::cout << "  Profile set to " << onvif_data->profileToken << "\n" << std::endl;
+	}
+	else {
+		if (!strcmp(onvif_data->profileToken, "")) {
+			if (getProfileToken(onvif_data, index)) throw std::runtime_error(cat("get profile token - ", onvif_data->last_error));
+			if (strlen(onvif_data->profileToken) == 0) throw std::runtime_error(cat("invalid profile token - ", (char*)std::to_string(index).c_str()).data());
+			std::cout << "  Profile set to " << onvif_data->profileToken << "\n" << std::endl;
+		}
+		else {
+			std::cout << std::endl;
+		}
+	}
+	if (getProfile(onvif_data)) throw std::runtime_error(cat("get profile - ", onvif_data->last_error));
+}
+
+int main(int argc, char **argv)
+{
+	int ch;
+	char *arg0 = argv[0];
+
+	while ((ch = getopt_long(argc, argv, "u:p:ah", longopts, NULL)) != -1) {
+		switch (ch) {
+            case 'u':
+				username = optarg;
+				break;
+			case 'p':
+				password = optarg;
+				break;
+			case 'a':
+				showAll();
+				exit(0);
+			case 'h':
+				showHelp();
+				exit(0);
+			case 0:
+				std::cout << "test 0:" << optarg << std::endl;
+				break;
+			default:
+				std::cout << "test default" << optarg << std::endl;
+				exit(1);
+		}
+	}
+	
+	argc -= optind;
+    argv += optind;
+
+	if (argc < 1) {
+		std::cout << "NO ARGS" << std::endl;
+		exit(1);
+	}
+
+	char *wanted = argv++[0];
+
+	struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
+	struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
+	initializeSession(onvif_session);
+	int n = broadcast(onvif_session);
+	for (int i = 0; i < n; i++) {
+		prepareOnvifData(i, onvif_session, onvif_data);
+		char host[128];
+		extractHost(onvif_data->xaddrs, host);
+		getHostname(onvif_data);
+		if (!strcmp(host, wanted)) {
+			std::cout << "  found host: " << host << std::endl;
+			strcpy(onvif_data->username, username);
+			strcpy(onvif_data->password, password);
+			if (getDeviceInformation(onvif_data)  == 0) {
+				std::cout << "  successfully connected to host" << "\n";
+				std::cout << "    name:   " << onvif_data->camera_name << "\n";
+				std::cout << "    serial: " << onvif_data->serial_number << "\n" << std::endl;
+	
+				// Initializing the session properly with the camera requires calling getCapabilities
+				if (getCapabilities(onvif_data)) {
+					std::cout << "ERROR: get capabilities - " << onvif_data->last_error << "\n" << std::endl;
+					exit(1);
+				}
+				break;
+			}
+			else {
+				std::cout << "ERROR: get device information - " << onvif_data->last_error << "\n" << std::endl;
+				exit(1);
+			}
+		}
+		if (i == n - 1) {
+			std::cout << "ERROR: camera " << wanted << " not found" << "\n" << std::endl;
+			exit(1);
+		}
+	}
+
+	char kybd_buf[128] = {0};
+	while (strcmp(kybd_buf, "quit")) {
+		memset(kybd_buf, 0, 128);
+		fgets(kybd_buf, 128, stdin);
+		kybd_buf[strcspn(kybd_buf, "\r\n")] = 0;
+
+		std::string cmd = std::string(kybd_buf);
+		if (cmd.length() == 0)
+			continue;
+		std::string arg;
+		std::vector<std::string> args;
+		std::stringstream ss(cmd);
+		while (ss >> arg)
+			args.push_back(arg);
+
+		try {
+			if (args[0] == "get") {
+
+				args.erase(args.begin());
+
+				if (args[0] == "rtsp") {
+					bool add_pass = false;
+					if (args.size() > 1) {
+						if (args[1] == "pass") {
+							args.erase(args.begin());
+							add_pass = true;
+						}
+					}
+					profileCheck(onvif_data, args);
+					if (getStreamUri(onvif_data)) throw std::runtime_error(cat("get stream uri - ", onvif_data->last_error));
+					std::string uri(onvif_data->stream_uri);
+					if (add_pass) {
+						uri = uri_with_pass(onvif_data);
+					}
+					std::cout << "  " << uri << "\n" << std::endl;
+				}
+				else if (args[0] == "capabilities") {
+					std::cout << "  event_service:   " << onvif_data->event_service << "\n";
+					std::cout << "  imaging_service: " << onvif_data->imaging_service << "\n";
+					std::cout << "  media_service:   " << onvif_data->imaging_service << "\n";
+					std::cout << "  ptz_service:     " << onvif_data->imaging_service << "\n" << std::endl;
+				}
+				else if (args[0] == "profiles") {
+					int index = 0;
+					bool looking = true;
+					while (looking) {
+						memset(onvif_data->profileToken, 0, 128);
+						if (getProfileToken(onvif_data, index)) throw std::runtime_error(cat("get profile token - ", onvif_data->last_error));
+						if (strlen(onvif_data->profileToken) == 0) 
+							looking = false;
+						else
+							std::cout << "  Token " << index << ": " << onvif_data->profileToken << "\n";
+							index++;
+					}
+					std::cout << std::endl;
+				}
+				else if (args[0] == "profile") {
+					profileCheck(onvif_data, args);
+					std::cout << "  Width:      " << onvif_data->width << "\n";
+					std::cout << "  Height:     " << onvif_data->height << "\n";
+					std::cout << "  Frame Rate: " << onvif_data->frame_rate << "\n";
+					std::cout << "  Gov Length: " << onvif_data->gov_length << "\n";
+					std::cout << "  Bitrate:    " << onvif_data->bitrate << "\n" << std::endl;
+				}
+				else if (args[0] == "time") {
+					if (getTimeOffset(onvif_data)) throw std::runtime_error(cat("get time offset - ", onvif_data->last_error));
+					std::cout << "  Time Offset: " << onvif_data->time_offset << " seconds" << "\n";
+					std::cout << "  Timezone:    " << onvif_data->timezone << "\n";
+					std::cout << "  DST:         " << (onvif_data->dst ? "Yes" : "No") << "\n" << std::endl;
+				}
+				else if (args[0] == "video") {
+
+					if (args[1] == "options") {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if(getVideoEncoderConfigurationOptions(onvif_data)) throw std::runtime_error(cat("get video encoder configuration options - ", onvif_data->last_error));
+						int size = 0;
+						bool found_size = false;
+						while (!found_size) {
+							if (strlen(onvif_data->resolutions_buf[size]) == 0) {
+								found_size = true;
+							}
+							else {
+								size++;
+								if (size > 15)
+									found_size = true;
+							}
+						}
+
+						std::cout << "  Available Resolutions" << std::endl;
+						for (int i=0; i<size; i++) {
+							std::cout << "    " << onvif_data->resolutions_buf[i] << std::endl;
+						}
+
+						std::cout <<  "  Min Gov Length: " << onvif_data->gov_length_min << "\n";
+						std::cout <<  "  Max Gov Length: " << onvif_data->gov_length_max << "\n";
+						std::cout <<  "  Min Frame Rate: " << onvif_data->frame_rate_min << "\n";
+						std::cout <<  "  Max Frame Rate: " << onvif_data->frame_rate_max << "\n";
+						std::cout <<  "  Min Bit Rate: " << onvif_data->bitrate_min << "\n";
+						std::cout <<  "  Max Bit Rate: " << onvif_data->bitrate_max << "\n" << std::endl;
+					}
+					else {
+						profileCheck(onvif_data, args);
+						if(getVideoEncoderConfigurationOptions(onvif_data)) throw std::runtime_error(cat("get video encoder configuration options - ", onvif_data->last_error));
+						std::cout << "  Resolution: " << onvif_data->width << " x " << onvif_data->height << "\n";
+						std::cout << "  Frame Rate: " << onvif_data->frame_rate << "\n";
+						std::cout << "  Gov Length: " << onvif_data->gov_length << "\n";
+						std::cout << "  Bit Rate:   " << onvif_data->bitrate << "\n" << std::endl;
+					}
+				}
+				else if (args[0] == "imaging") {
+
+					if (args[1] == "options") {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getOptions(onvif_data)) throw std::runtime_error(cat("get options - ", onvif_data->last_error));
+						std::cout << "  Min Brightness: " << onvif_data->brightness_min << "\n";
+						std::cout << "  Max Brightness: " << onvif_data->brightness_max << "\n";
+						std::cout << "  Min ColorSaturation: " << onvif_data->saturation_min << "\n";
+						std::cout << "  Max ColorSaturation: " << onvif_data->saturation_max << "\n";
+						std::cout << "  Min Contrast: " << onvif_data->contrast_min << "\n";
+						std::cout << "  Max Contrast: " << onvif_data->contrast_max << "\n";
+						std::cout << "  Min Sharpness: " << onvif_data->sharpness_min << "\n";
+						std::cout << "  Max Sharpness: " << onvif_data->sharpness_max << "\n" << std::endl;
+					}
+					else {
+						profileCheck(onvif_data, args);
+						if (getImagingSettings(onvif_data)) throw std::runtime_error(cat("get imaging settings - ", onvif_data->last_error));
+
+						std::cout << "  Brightness: " << onvif_data->brightness << "\n";
+						std::cout << "  Contrast:   " << onvif_data->contrast << "\n";
+						std::cout << "  Saturation: " << onvif_data->saturation << "\n";
+						std::cout << "  Sharpness:  " << onvif_data->sharpness << "\n" << std::endl;
+					}
+				}
+				else if (args[0] == "network") {
+					profileCheck(onvif_data, args);
+					if (getNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("get network interfaces - ", onvif_data->last_error));
+					if (getNetworkDefaultGateway(onvif_data)) throw std::runtime_error(cat("get network default gateway - ", onvif_data->last_error));
+					if (getDNS(onvif_data)) throw std::runtime_error(cat("get DNS - ", onvif_data->last_error));
+
+					std::cout << "  IP Address: " << onvif_data->ip_address_buf << "\n";
+					std::cout << "  Gateway:    " << onvif_data->default_gateway_buf << "\n";
+					std::cout << "  DNS:        " << onvif_data->dns_buf << "\n";
+					std::cout << "  DHCP:       " << (onvif_data->dhcp_enabled ? "YES" : "NO") << "\n" << std::endl;
+				}
+				else { 
+					std::cout << "  Unrecognized command, use onvif-util -h to see help\n" << std::endl;
+				}
+			}
+			else if (args[0] == "set") {
+				args.erase(args.begin());
+				if (args[0] == "brightness") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getImagingSettings(onvif_data)) throw std::runtime_error(cat("get imaging settings - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->brightness = value;
+						if (setImagingSettings(onvif_data)) throw std::runtime_error(cat("set brightness - ", onvif_data->last_error));
+						std::cout << "  Brightness was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for brightness\n" << std::endl;
+					}
+				}
+				else if (args[0] == "contrast") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getImagingSettings(onvif_data)) throw std::runtime_error(cat("get imaging settings - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->contrast = value;
+						if (setImagingSettings(onvif_data)) throw std::runtime_error(cat("set contrast - ", onvif_data->last_error));
+						std::cout << "  Contrast was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for contrast\n" << std::endl;
+					}
+				}
+				else if (args[0] == "saturation") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getImagingSettings(onvif_data)) throw std::runtime_error(cat("get imaging settings - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->saturation = value;
+						if (setImagingSettings(onvif_data)) throw std::runtime_error(cat("set saturation - ", onvif_data->last_error));
+						std::cout << "  Saturation was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for saturation\n" << std::endl;
+					}
+				}
+				else if (args[0] == "sharpness") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getImagingSettings(onvif_data)) throw std::runtime_error(cat("get imaging settings - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->sharpness = value;
+						if (setImagingSettings(onvif_data)) throw std::runtime_error(cat("set sharpness - ", onvif_data->last_error));
+						std::cout << "  Sharpness was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for sharpness\n" << std::endl;
+					}
+				}
+				else if (args[0] == "resolution") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						std::string delim = "x";
+						std::size_t found = args[0].find(delim);
+						if (found != std::string::npos) {
+							if(getVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("get video encoder configuration - ", onvif_data->last_error));
+							onvif_data->width = stoi(args[0].substr(0, found));
+							onvif_data->height = stoi(args[0].substr(found+1));
+							if (setVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("set video encoder configuration - ", onvif_data->last_error));
+							std::cout << "  Resolution was set to " << onvif_data->width << " x " << onvif_data->height << "\n" << std::endl;
+						}
+						else {
+							std::cout << "  Syntax error, proper format for the argument is widthxheight e.g. 1280x720" << std::endl;
+						}
+					}
+ 				}
+				else if (args[0] == "gov_length") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if(getVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("get video encoder configuration - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->gov_length = value;
+						if (setVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("set video encoder configuration - ", onvif_data->last_error));
+						std::cout << "  Gov Length was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for Gov Length\n" << std::endl;
+					}
+				}
+				else if (args[0] == "framerate") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if(getVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("get video encoder configuration - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->frame_rate = value;
+						if (setVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("set video encoder configuration - ", onvif_data->last_error));
+						std::cout << "  Frame Rate was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for Frame Rate\n" << std::endl;
+					}
+				}
+				else if (args[0] == "bitrate") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if(getVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("get video encoder configuration - ", onvif_data->last_error));
+						int value = stoi(args[0]);
+						onvif_data->bitrate = value;
+						if (setVideoEncoderConfiguration(onvif_data)) throw std::runtime_error(cat("set video encoder configuration - ", onvif_data->last_error));
+						std::cout << "  Bitrate was set to " << value << "\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for Bitrate\n" << std::endl;
+					}
+				}
+				else if (args[0] == "dhcp") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						if (args[0] == "on") {
+							profileCheck(onvif_data, args);
+							if (getNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("get network interfaces - ", onvif_data->last_error));
+							if (onvif_data->dhcp_enabled) {
+								std::cout << "  DHCP is already enabled\n" << std::endl;
+							}
+							else {
+								onvif_data->dhcp_enabled = true;
+								if (setNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("set network interfaces - ", onvif_data->last_error));
+								std::cout << "  DHCP was enabled successfully\n\n"
+										  << "  Camera may or may not reboot depending on settings\n"
+										  << "  Session is being terminated.\n" << std::endl;
+								exit(0);
+							}
+						}
+						else if (args[0] == "off") {
+							profileCheck(onvif_data, args);
+							if (getNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("get network interfaces - ", onvif_data->last_error));
+							if (!onvif_data->dhcp_enabled) {
+								std::cout << "  DHCP is already disabled\n" << std::endl;
+							}
+							else {
+								onvif_data->dhcp_enabled = false;
+								if (setNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("set network interfaces - ", onvif_data->last_error));
+								std::cout << "  DHCP disabled\n" << std::endl;
+							}
+						}
+						else {
+							std::cout << "  Invalid value for DHCP, use either 'on' or 'off\n" << std::endl;
+						}
+					}
+					else {
+						std::cout << "  Missing value for DHCP\n" << std::endl;
+					}
+				}
+				else if (args[0] == "ip_address") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("get network interfaces - ", onvif_data->last_error));
+						if (onvif_data->dhcp_enabled) {
+							std::cout << "  Camera DHCP is enabled, IP address may not be set manually\n" << std::endl;
+						}
+						else {
+							strcpy(onvif_data->ip_address_buf, args[0].c_str());
+							if (setNetworkInterfaces(onvif_data)) throw std::runtime_error(cat("set network interfaces - ", onvif_data->last_error));
+							std::cout << "  IP Address has been changed, session will need to be restarted\n" << std::endl;
+							exit(0);
+						}
+					}
+					else {
+						std::cout << "  Missing value for IP address\n" << std::endl;
+					}
+				}
+				else if (args[0] == "default_gateway") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getNetworkDefaultGateway(onvif_data)) throw std::runtime_error(cat("get network default gateway - ", onvif_data->last_error));
+						if (onvif_data->dhcp_enabled) {
+							std::cout << "  Camera DHCP is enabled, default gateway may not be set manually\n" << std::endl;
+						}
+						else {
+							strcpy(onvif_data->default_gateway_buf, args[0].c_str());
+							if (setNetworkDefaultGateway(onvif_data)) throw std::runtime_error(cat("set default gateway - ", onvif_data->last_error));
+							std::cout << "  Default gateway has been changed\n" << std::endl;
+						}
+					}
+					else {
+						std::cout << "  Missing value for default gateway\n" << std::endl;
+					}
+				}
+				else if (args[0] == "dns") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						if (getDNS(onvif_data)) throw std::runtime_error(cat("get DNS - ", onvif_data->last_error));
+						if (onvif_data->dhcp_enabled) {
+							std::cout << "  Camera DHCP is enabled, DNS may not be set manually\n" << std::endl;
+						}
+						else {
+							strcpy(onvif_data->dns_buf, args[0].c_str());
+							if (setDNS(onvif_data)) throw std::runtime_error(cat("set DNS - ", onvif_data->last_error));
+							std::cout << "  DNS has been changed\n" << std::endl;
+						}
+					}
+					else {
+						std::cout << "  Missing value for DNS\n" << std::endl;
+					}
+				}
+				else if (args[0] == "password") {
+					if (args.size() > 1) {
+						args.erase(args.begin());
+						profileCheck(onvif_data, args);
+						char buf[128] = {0};
+						strcpy(buf, args[0].c_str());
+						if (setUser(buf, onvif_data)) throw std::runtime_error(cat("set user - ", onvif_data->last_error));
+						std::cout << "  Admin password has been reset\n" << std::endl;
+					}
+					else {
+						std::cout << "  Missing value for admin password\n" << std::endl;
+ 					}
+				}
+				else { 
+					std::cout << "  Unrecognized command, use onvif-util -h to see help\n" << std::endl;
+				}
+			}
+			else if (args[0] == "reboot") {
+				std::cout << "  Are you sure you want to reboot?  Type yes to confirm\n" << std::endl;
+				memset(kybd_buf, 0, 128);
+				fgets(kybd_buf, 128, stdin);
+				kybd_buf[strcspn(kybd_buf, "\r\n")] = 0;
+				std::string reply(kybd_buf);
+				if (reply == "yes") {
+					if (rebootCamera(onvif_data)) throw std::runtime_error(cat("reboot camera - ", onvif_data->last_error));
+					std::cout << "  Camera is rebooting...\n" 
+					          << "  Session will be terminated" << std::endl;
+				}
+				else {
+					std::cout << "  Confirmation not received, reboot cancelled\n" << std::endl;
+				}
+			}
+			else if (args[0] == "sync_time") {
+				if (args.size() > 1) {
+					args.erase(args.begin());
+					profileCheck(onvif_data, args);
+					if (args[0] == "zone") {
+						profileCheck(onvif_data, args);
+						if (setSystemDateAndTimeUsingTimezone(onvif_data)) throw std::runtime_error(cat("set system date and time using timezone - ", onvif_data->last_error));
+						std::cout << "  Camera date and time has been synchronized using the camera timezone\n" << std::endl;
+					}
+				}
+				else {
+					profileCheck(onvif_data, args);
+					if (setSystemDateAndTime(onvif_data)) throw std::runtime_error(cat("set system date and time - ", onvif_data->last_error));
+					std::cout << "  Camera date and time has been synchronized without regard to camera timezone\n" << std::endl;
+				}
+			}
+			else if (args[0] == "view") {
+				std::string player("ffplay");
+				if (args.size() > 1) {
+					args.erase(args.begin());
+					profileCheck(onvif_data, args);
+					player = args[0];
+				}
+				else {
+					profileCheck(onvif_data, args);
+				}
+				if (getStreamUri(onvif_data)) throw std::runtime_error(cat("get stream uri - ", onvif_data->last_error));
+				std::stringstream ss;
+#ifdef _WIN32
+				ss << "start " << player << " \"" << uri_with_pass(onvif_data) << "\"";
+#else
+				ss << player << " \"" << uri_with_pass(onvif_data) << "\"";
+#endif				
+				std::system(ss.str().c_str());
+			} 
+			else if (args[0] == "help") {
+				showHelp();
+			}
+			else { 
+				if (strcmp(kybd_buf, "quit"))
+					std::cout << " Unrecognized command, use onvif-util -h to see help\n" << std::endl;
+			}
+		}
+		catch (std::runtime_error& e) {
+			std::cout << "  ERROR: " << e.what() << "\n" << std::endl;
+		}
+	}
+}
+
+/*
+else if (args[0] == "video") {
+	profileCheck(onvif_data, args);
+	if (getVideoEncoderConfigurationOptions(onvif_data)) throw std::runtime_error(cat("get video encoder configuration options - ", onvif_data->last_error));
+	std::cout << "  Name: " << onvif_data->video_encoder_name_buf << "\n";
+	std::cout << "  UseCount: " << onvif_data->use_count << "\n";
+	std::cout << "  GuaranteedFrameRate: " << (onvif_data->guaranteed_frame_rate?"true":"false") << "\n";
+	std::cout << "  Encoding: " << onvif_data->encoding << "\n";
+	std::cout << "  Resolution:Width: " << onvif_data->conf_width << "\n";
+	std::cout << "  Resolution:Height: " << onvif_data->conf_height << "\n";
+	std::cout << "  Quality: " << onvif_data->quality << "\n";
+	std::cout << "  RateControl:FrameRateLimit: " << onvif_data->conf_frame_rate_limit << "\n";
+	std::cout << "  RateControl:EncodingInterval: " << onvif_data->conf_encoding_interval << "\n";
+	std::cout << "  RateControl:BitrateLimit: " << onvif_data->conf_bitrate_limit << "\n";
+	std::cout << "  H264Profile: " << onvif_data->h264_profile_buf << "\n";
+	std::cout << "  Multicast:AddressType: " << onvif_data->multicast_address_type_buf << "\n";
+	if (strcmp(onvif_data->multicast_address_type_buf,"IPv6") == 0)
+		std::cout << "  Multicast:IPv6Address: " << onvif_data->multicast_address_buf << "\n";
+	else
+		std::cout << "  Multicast:IPv4Address: " << onvif_data->multicast_address_buf << "\n";
+	std::cout << "  Multicast:Port: " << onvif_data->multicast_port << "\n";
+	std::cout << "  Multicast:TTL: " << onvif_data->multicast_ttl << "\n";
+	std::cout << "  Multicast:AutoStart: " << (onvif_data->autostart?"true":"false") << "\n";
+	std::cout << "  SessionTimeout: " << onvif_data->session_time_out_buf << "\n" << std::endl;
+}
+*/
diff --git a/include/getopt-win.h b/include/getopt-win.h
new file mode 100644
index 0000000..a07ffd2
--- /dev/null
+++ b/include/getopt-win.h
@@ -0,0 +1,653 @@
+#ifndef __GETOPT_H__
+/**
+ * DISCLAIMER
+ * This file is part of the mingw-w64 runtime package.
+ *
+ * The mingw-w64 runtime package and its code is distributed in the hope that it 
+ * will be useful but WITHOUT ANY WARRANTY.  ALL WARRANTIES, EXPRESSED OR 
+ * IMPLIED ARE HEREBY DISCLAIMED.  This includes but is not limited to 
+ * warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+ /*
+ * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F39502-99-1-0512.
+ */
+/*-
+ * Copyright (c) 2000 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Dieter Baron and Thomas Klausner.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma warning(disable:4996)
+
+#define __GETOPT_H__
+
+/* All the headers include this file. */
+#include <crtdefs.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <windows.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	REPLACE_GETOPT		/* use this getopt as the system getopt(3) */
+
+#ifdef REPLACE_GETOPT
+int	opterr = 1;		/* if error message should be printed */
+int	optind = 1;		/* index into parent argv vector */
+int	optopt = '?';		/* character checked for validity */
+#undef	optreset		/* see getopt.h */
+#define	optreset		__mingw_optreset
+int	optreset;		/* reset getopt */
+char    *optarg;		/* argument associated with option */
+#endif
+
+//extern int optind;		/* index of first non-option in argv      */
+//extern int optopt;		/* single option character, as parsed     */
+//extern int opterr;		/* flag to enable built-in diagnostics... */
+//				/* (user may set to zero, to suppress)    */
+//
+//extern char *optarg;		/* pointer to argument of current option  */
+
+#define PRINT_ERROR	((opterr) && (*options != ':'))
+
+#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
+#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
+#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */
+
+/* return values */
+#define	BADCH		(int)'?'
+#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
+#define	INORDER 	(int)1
+
+#ifndef __CYGWIN__
+#define __progname __argv[0]
+#else
+extern char __declspec(dllimport) *__progname;
+#endif
+
+#ifdef __CYGWIN__
+static char EMSG[] = "";
+#else
+#define	EMSG		""
+#endif
+
+static int getopt_internal(int, char * const *, const char *,
+			   const struct option *, int *, int);
+static int parse_long_options(char * const *, const char *,
+			      const struct option *, int *, int);
+static int gcd(int, int);
+static void permute_args(int, int, int, char * const *);
+
+static char *place = EMSG; /* option letter processing */
+
+/* XXX: set optreset to 1 rather than these two */
+static int nonopt_start = -1; /* first non option argument (for permute) */
+static int nonopt_end = -1;   /* first option after non options (for permute) */
+
+/* Error messages */
+static const char recargchar[] = "option requires an argument -- %c";
+static const char recargstring[] = "option requires an argument -- %s";
+static const char ambig[] = "ambiguous option -- %.*s";
+static const char noarg[] = "option doesn't take an argument -- %.*s";
+static const char illoptchar[] = "unknown option -- %c";
+static const char illoptstring[] = "unknown option -- %s";
+
+static void
+_vwarnx(const char *fmt,va_list ap)
+{
+  (void)fprintf(stderr,"%s: ",__progname);
+  if (fmt != NULL)
+    (void)vfprintf(stderr,fmt,ap);
+  (void)fprintf(stderr,"\n");
+}
+
+static void
+warnx(const char *fmt,...)
+{
+  va_list ap;
+  va_start(ap,fmt);
+  _vwarnx(fmt,ap);
+  va_end(ap);
+}
+
+/*
+ * Compute the greatest common divisor of a and b.
+ */
+static int
+gcd(int a, int b)
+{
+	int c;
+
+	c = a % b;
+	while (c != 0) {
+		a = b;
+		b = c;
+		c = a % b;
+	}
+
+	return (b);
+}
+
+/*
+ * Exchange the block from nonopt_start to nonopt_end with the block
+ * from nonopt_end to opt_end (keeping the same order of arguments
+ * in each block).
+ */
+static void
+permute_args(int panonopt_start, int panonopt_end, int opt_end,
+	char * const *nargv)
+{
+	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
+	char *swap;
+
+	/*
+	 * compute lengths of blocks and number and size of cycles
+	 */
+	nnonopts = panonopt_end - panonopt_start;
+	nopts = opt_end - panonopt_end;
+	ncycle = gcd(nnonopts, nopts);
+	cyclelen = (opt_end - panonopt_start) / ncycle;
+
+	for (i = 0; i < ncycle; i++) {
+		cstart = panonopt_end+i;
+		pos = cstart;
+		for (j = 0; j < cyclelen; j++) {
+			if (pos >= panonopt_end)
+				pos -= nnonopts;
+			else
+				pos += nopts;
+			swap = nargv[pos];
+			/* LINTED const cast */
+			((char **) nargv)[pos] = nargv[cstart];
+			/* LINTED const cast */
+			((char **)nargv)[cstart] = swap;
+		}
+	}
+}
+
+#ifdef REPLACE_GETOPT
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ *
+ * [eventually this will replace the BSD getopt]
+ */
+int
+getopt(int nargc, char * const *nargv, const char *options)
+{
+
+	/*
+	 * We don't pass FLAG_PERMUTE to getopt_internal() since
+	 * the BSD getopt(3) (unlike GNU) has never done this.
+	 *
+	 * Furthermore, since many privileged programs call getopt()
+	 * before dropping privileges it makes sense to keep things
+	 * as simple (and bug-free) as possible.
+	 */
+	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
+}
+#endif /* REPLACE_GETOPT */
+
+//extern int getopt(int nargc, char * const *nargv, const char *options);
+
+#ifdef _BSD_SOURCE
+/*
+ * BSD adds the non-standard `optreset' feature, for reinitialisation
+ * of `getopt' parsing.  We support this feature, for applications which
+ * proclaim their BSD heritage, before including this header; however,
+ * to maintain portability, developers are advised to avoid it.
+ */
+# define optreset  __mingw_optreset
+extern int optreset;
+#endif
+#ifdef __cplusplus
+}
+#endif
+/*
+ * POSIX requires the `getopt' API to be specified in `unistd.h';
+ * thus, `unistd.h' includes this header.  However, we do not want
+ * to expose the `getopt_long' or `getopt_long_only' APIs, when
+ * included in this manner.  Thus, close the standard __GETOPT_H__
+ * declarations block, and open an additional __GETOPT_LONG_H__
+ * specific block, only when *not* __UNISTD_H_SOURCED__, in which
+ * to declare the extended API.
+ */
+#endif /* !defined(__GETOPT_H__) */
+
+#if !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__)
+#define __GETOPT_LONG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct option		/* specification for a long form option...	*/
+{
+  const char *name;		/* option name, without leading hyphens */
+  int         has_arg;		/* does it take an argument?		*/
+  int        *flag;		/* where to save its status, or NULL	*/
+  int         val;		/* its associated status value		*/
+};
+
+enum    		/* permitted values for its `has_arg' field...	*/
+{
+  no_argument = 0,      	/* option never takes an argument	*/
+  required_argument,		/* option always requires an argument	*/
+  optional_argument		/* option may take an argument		*/
+};
+
+/*
+ * parse_long_options --
+ *	Parse long options in argc/argv argument vector.
+ * Returns -1 if short_too is set and the option does not match long_options.
+ */
+static int
+parse_long_options(char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int short_too)
+{
+	char *current_argv, *has_equal;
+	size_t current_argv_len;
+	int i, ambiguous, match;
+
+#define IDENTICAL_INTERPRETATION(_x, _y)                                \
+	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
+	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
+	 long_options[(_x)].val == long_options[(_y)].val)
+
+	current_argv = place;
+	match = -1;
+	ambiguous = 0;
+
+	optind++;
+
+	if ((has_equal = strchr(current_argv, '=')) != NULL) {
+		/* argument found (--option=arg) */
+		current_argv_len = has_equal - current_argv;
+		has_equal++;
+	} else
+		current_argv_len = strlen(current_argv);
+
+	for (i = 0; long_options[i].name; i++) {
+		/* find matching long option */
+		if (strncmp(current_argv, long_options[i].name,
+		    current_argv_len))
+			continue;
+
+		if (strlen(long_options[i].name) == current_argv_len) {
+			/* exact match */
+			match = i;
+			ambiguous = 0;
+			break;
+		}
+		/*
+		 * If this is a known short option, don't allow
+		 * a partial match of a single character.
+		 */
+		if (short_too && current_argv_len == 1)
+			continue;
+
+		if (match == -1)	/* partial match */
+			match = i;
+		else if (!IDENTICAL_INTERPRETATION(i, match))
+			ambiguous = 1;
+	}
+	if (ambiguous) {
+		/* ambiguous abbreviation */
+		if (PRINT_ERROR)
+			warnx(ambig, (int)current_argv_len,
+			     current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (match != -1) {		/* option found */
+		if (long_options[match].has_arg == no_argument
+		    && has_equal) {
+			if (PRINT_ERROR)
+				warnx(noarg, (int)current_argv_len,
+				     current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+			return (BADARG);
+		}
+		if (long_options[match].has_arg == required_argument ||
+		    long_options[match].has_arg == optional_argument) {
+			if (has_equal)
+				optarg = has_equal;
+			else if (long_options[match].has_arg ==
+			    required_argument) {
+				/*
+				 * optional argument doesn't use next nargv
+				 */
+				optarg = nargv[optind++];
+			}
+		}
+		if ((long_options[match].has_arg == required_argument)
+		    && (optarg == NULL)) {
+			/*
+			 * Missing argument; leading ':' indicates no error
+			 * should be generated.
+			 */
+			if (PRINT_ERROR)
+				warnx(recargstring,
+				    current_argv);
+			/*
+			 * XXX: GNU sets optopt to val regardless of flag
+			 */
+			if (long_options[match].flag == NULL)
+				optopt = long_options[match].val;
+			else
+				optopt = 0;
+			--optind;
+			return (BADARG);
+		}
+	} else {			/* unknown option */
+		if (short_too) {
+			--optind;
+			return (-1);
+		}
+		if (PRINT_ERROR)
+			warnx(illoptstring, current_argv);
+		optopt = 0;
+		return (BADCH);
+	}
+	if (idx)
+		*idx = match;
+	if (long_options[match].flag) {
+		*long_options[match].flag = long_options[match].val;
+		return (0);
+	} else
+		return (long_options[match].val);
+#undef IDENTICAL_INTERPRETATION
+}
+
+/*
+ * getopt_internal --
+ *	Parse argc/argv argument vector.  Called by user level routines.
+ */
+static int
+getopt_internal(int nargc, char * const *nargv, const char *options,
+	const struct option *long_options, int *idx, int flags)
+{
+	char *oli;				/* option letter list index */
+	int optchar, short_too;
+	static int posixly_correct = -1;
+
+	if (options == NULL)
+		return (-1);
+
+	/*
+	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
+	 * XXX using optreset.  Work around this braindamage.
+	 */
+	if (optind == 0)
+		optind = optreset = 1;
+
+	/*
+	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
+	 * string begins with a '+'.
+	 *
+	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
+	 *                 optreset != 0 for GNU compatibility.
+	 */
+	if (posixly_correct == -1 || optreset != 0)
+		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
+	if (*options == '-')
+		flags |= FLAG_ALLARGS;
+	else if (posixly_correct || *options == '+')
+		flags &= ~FLAG_PERMUTE;
+	if (*options == '+' || *options == '-')
+		options++;
+
+	optarg = NULL;
+	if (optreset)
+		nonopt_start = nonopt_end = -1;
+start:
+	if (optreset || !*place) {		/* update scanning pointer */
+		optreset = 0;
+		if (optind >= nargc) {          /* end of argument vector */
+			place = EMSG;
+			if (nonopt_end != -1) {
+				/* do permutation, if we have to */
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			else if (nonopt_start != -1) {
+				/*
+				 * If we skipped non-options, set optind
+				 * to the first of them.
+				 */
+				optind = nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+		if (*(place = nargv[optind]) != '-' ||
+		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
+			place = EMSG;		/* found non-option */
+			if (flags & FLAG_ALLARGS) {
+				/*
+				 * GNU extension:
+				 * return non-option as argument to option 1
+				 */
+				optarg = nargv[optind++];
+				return (INORDER);
+			}
+			if (!(flags & FLAG_PERMUTE)) {
+				/*
+				 * If no permutation wanted, stop parsing
+				 * at first non-option.
+				 */
+				return (-1);
+			}
+			/* do permutation */
+			if (nonopt_start == -1)
+				nonopt_start = optind;
+			else if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				nonopt_start = optind -
+				    (nonopt_end - nonopt_start);
+				nonopt_end = -1;
+			}
+			optind++;
+			/* process next argument */
+			goto start;
+		}
+		if (nonopt_start != -1 && nonopt_end == -1)
+			nonopt_end = optind;
+
+		/*
+		 * If we have "-" do nothing, if "--" we are done.
+		 */
+		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
+			optind++;
+			place = EMSG;
+			/*
+			 * We found an option (--), so if we skipped
+			 * non-options, we have to permute.
+			 */
+			if (nonopt_end != -1) {
+				permute_args(nonopt_start, nonopt_end,
+				    optind, nargv);
+				optind -= nonopt_end - nonopt_start;
+			}
+			nonopt_start = nonopt_end = -1;
+			return (-1);
+		}
+	}
+
+	/*
+	 * Check long options if:
+	 *  1) we were passed some
+	 *  2) the arg is not just "-"
+	 *  3) either the arg starts with -- we are getopt_long_only()
+	 */
+	if (long_options != NULL && place != nargv[optind] &&
+	    (*place == '-' || (flags & FLAG_LONGONLY))) {
+		short_too = 0;
+		if (*place == '-')
+			place++;		/* --foo long option */
+		else if (*place != ':' && strchr(options, *place) != NULL)
+			short_too = 1;		/* could be short option too */
+
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, short_too);
+		if (optchar != -1) {
+			place = EMSG;
+			return (optchar);
+		}
+	}
+
+	if ((optchar = (int)*place++) == (int)':' ||
+	    (optchar == (int)'-' && *place != '\0') ||
+	    (oli = (char*)strchr(options, optchar)) == NULL) {
+		/*
+		 * If the user specified "-" and  '-' isn't listed in
+		 * options, return -1 (non-option) as per POSIX.
+		 * Otherwise, it is an unknown option character (or ':').
+		 */
+		if (optchar == (int)'-' && *place == '\0')
+			return (-1);
+		if (!*place)
+			++optind;
+		if (PRINT_ERROR)
+			warnx(illoptchar, optchar);
+		optopt = optchar;
+		return (BADCH);
+	}
+	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
+		/* -W long-option */
+		if (*place)			/* no space */
+			/* NOTHING */;
+		else if (++optind >= nargc) {	/* no arg */
+			place = EMSG;
+			if (PRINT_ERROR)
+				warnx(recargchar, optchar);
+			optopt = optchar;
+			return (BADARG);
+		} else				/* white space */
+			place = nargv[optind];
+		optchar = parse_long_options(nargv, options, long_options,
+		    idx, 0);
+		place = EMSG;
+		return (optchar);
+	}
+	if (*++oli != ':') {			/* doesn't take argument */
+		if (!*place)
+			++optind;
+	} else {				/* takes (optional) argument */
+		optarg = NULL;
+		if (*place)			/* no white space */
+			optarg = place;
+		else if (oli[1] != ':') {	/* arg not optional */
+			if (++optind >= nargc) {	/* no arg */
+				place = EMSG;
+				if (PRINT_ERROR)
+					warnx(recargchar, optchar);
+				optopt = optchar;
+				return (BADARG);
+			} else
+				optarg = nargv[optind];
+		}
+		place = EMSG;
+		++optind;
+	}
+	/* dump back option letter */
+	return (optchar);
+}
+
+/*
+ * getopt_long --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE));
+}
+
+/*
+ * getopt_long_only --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt_long_only(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+
+	return (getopt_internal(nargc, nargv, options, long_options, idx,
+	    FLAG_PERMUTE|FLAG_LONGONLY));
+}
+
+//extern int getopt_long(int nargc, char * const *nargv, const char *options,
+//    const struct option *long_options, int *idx);
+//extern int getopt_long_only(int nargc, char * const *nargv, const char *options,
+//    const struct option *long_options, int *idx);
+/*
+ * Previous MinGW implementation had...
+ */
+#ifndef HAVE_DECL_GETOPT
+/*
+ * ...for the long form API only; keep this for compatibility.
+ */
+# define HAVE_DECL_GETOPT	1
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__) */
\ No newline at end of file
diff --git a/include/onvif.h b/include/onvif.h
old mode 100755
new mode 100644
index 714ab55..22264f3
--- a/include/onvif.h
+++ b/include/onvif.h
@@ -69,6 +69,13 @@ struct OnvifData {
     int multicast_ttl;
     bool autostart;
     char session_time_out_buf[128];
+	bool guaranteed_frame_rate;
+    char encoding[128];
+    int conf_width;
+    int conf_height;
+    int conf_frame_rate_limit;
+    int conf_encoding_interval;
+    int conf_bitrate_limit;
     /*network*/
     char networkInterfaceToken[128];
     char networkInterfaceName[128];
@@ -109,8 +116,16 @@ struct OnvifData {
     char stream_uri[1024];
     char camera_name[1024];
     char serial_number[128];
+    char host_name[1024];
     /*error*/
     char last_error[1024];
+	/*date/time*/
+	char datetimetype;
+	bool dst;
+	char timezone[128];
+	bool ntp_dhcp;
+	char ntp_type[128];
+	char ntp_addr[128];
 };
 
 struct OnvifSession {
@@ -124,7 +139,8 @@ LIBRARY_API void initializeSession(struct OnvifSession *onvif_session);
 LIBRARY_API void closeSession(struct OnvifSession *onvif_session);
 LIBRARY_API int broadcast(struct OnvifSession *onvif_session);
 LIBRARY_API void prepareOnvifData(int ordinal, struct OnvifSession *onvif_session, struct OnvifData *onvif_data);
-LIBRARY_API int fillRTSP(struct OnvifData *onvif_data);
+LIBRARY_API int fillRTSPn(struct OnvifData *onvif_data, int profileIndex);
+#define fillRTSP(a) fillRTSPn(a,0)
 LIBRARY_API void clearData(struct OnvifData *onvif_data);
 
 LIBRARY_API int getCapabilities(struct OnvifData *onvif_data);
@@ -136,6 +152,10 @@ LIBRARY_API int getNetworkDefaultGateway(struct OnvifData *onvif_data);
 LIBRARY_API int setNetworkDefaultGateway(struct OnvifData *onvif_data);
 LIBRARY_API int getDNS(struct OnvifData *onvif_data);
 LIBRARY_API int setDNS(struct OnvifData *onvif_data);
+LIBRARY_API int getNTP(struct OnvifData *onvif_data);
+LIBRARY_API int setNTP(struct OnvifData *onvif_data);
+LIBRARY_API int getHostname(struct OnvifData *onvif_data);
+LIBRARY_API int setHostname(struct OnvifData *onvif_data);
 
 LIBRARY_API int getVideoEncoderConfigurationOptions(struct OnvifData *onvif_data);
 LIBRARY_API int getVideoEncoderConfiguration(struct OnvifData *onvif_data);
@@ -152,8 +172,10 @@ LIBRARY_API int gotoPreset(char * arg, struct OnvifData *onvif_data);
 
 LIBRARY_API int setUser(char * new_password, struct OnvifData *onvif_data);
 LIBRARY_API int setSystemDateAndTime(struct OnvifData *onvif_data);
+LIBRARY_API int setSystemDateAndTimeUsingTimezone(struct OnvifData *onvif_data);
 LIBRARY_API int getTimeOffset(struct OnvifData *onvif_data);
-LIBRARY_API int getFirstProfileToken(struct OnvifData *onvif_data);
+LIBRARY_API int getProfileToken(struct OnvifData *onvif_data, int profileIndex);
+#define getFirstProfileToken(a) getProfileToken(a,0)
 LIBRARY_API int getStreamUri(struct OnvifData *onvif_data);
 LIBRARY_API int getDeviceInformation(struct OnvifData *onvif_data);
 LIBRARY_API int rebootCamera(struct OnvifData *onvif_data);
@@ -183,7 +205,8 @@ LIBRARY_API void extractOnvifService(char service[1024], bool post);
 LIBRARY_API void extractHost(char * xaddrs, char host[128]);
 LIBRARY_API int checkForXmlErrorMsg(xmlDocPtr doc, char error_msg[1024]);
 LIBRARY_API int getXmlValue(xmlDocPtr doc, xmlChar *xpath, char buf[], int buf_length);
-LIBRARY_API int getNodeAttribute (xmlDocPtr doc, xmlChar *xpath, xmlChar *attribute, char buf[], int buf_length);
+LIBRARY_API int getNodeAttributen (xmlDocPtr doc, xmlChar *xpath, xmlChar *attribute, char buf[], int buf_length, int profileIndex);
+#define getNodeAttribute(doc,xpath,attribute,buf,buf_length) getNodeAttributen(doc,xpath,attribute,buf,buf_length,0)
 LIBRARY_API xmlXPathObjectPtr getNodeSet (xmlDocPtr doc, xmlChar *xpath);
 
 LIBRARY_API int setSocketOptions(int socket);
@@ -191,6 +214,8 @@ LIBRARY_API void prefix2mask(int prefix, char mask_buf[128]);
 LIBRARY_API int mask2prefix(char * mask_buf);
 LIBRARY_API void getIPAddress(char buf[128]);
 
+LIBRARY_API void dumpConfigAll (struct OnvifData *onvif_data);
+
 #ifdef __MINGW32__
     int inet_pton(int af, const char *src, void *dst);
     const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
diff --git a/recipe/bld.bat b/recipe/bld.bat
index 236e926..add48ed 100644
--- a/recipe/bld.bat
+++ b/recipe/bld.bat
@@ -1,5 +1,26 @@
+REM*******************************************************************************
+REM libovnif/recipe/meta.yaml
+REM
+REM Copyright (c) 2020 Stephen Rhodes 
+REM
+REM This program is free software; you can redistribute it and/or modify
+REM it under the terms of the GNU General Public License as published by
+REM the Free Software Foundation; either version 2 of the License, or
+REM (at your option) any later version.
+REM
+REM This program is distributed in the hope that it will be useful,
+REM but WITHOUT ANY WARRANTY; without even the implied warranty of
+REM MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+REM GNU General Public License for more details.
+REM
+REM You should have received a copy of the GNU General Public License along
+REM with this program; if not, write to the Free Software Foundation, Inc.,
+REM 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+REM
+REM******************************************************************************/
+
 mkdir build
 cd build
-cmake -G "NMake Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="%LIBRARY_PREFIX%" -DCMAKE_BUILD_TYPE:STRING=Release ..
+cmake -G "NMake Makefiles" -DCMAKE_INSTALL_PREFIX:PATH="%LIBRARY_PREFIX%" -DCMAKE_BUILD_TYPE:STRING=Release -DBUILD_GUI=ON ..
 nmake
 nmake install
diff --git a/recipe/build.sh b/recipe/build.sh
index e13b296..f3c88e5 100644
--- a/recipe/build.sh
+++ b/recipe/build.sh
@@ -1,5 +1,26 @@
+#*******************************************************************************
+# libovnif/recipe/build.sh
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
 echo "BUILD.SH"
 mkdir build
 cd build
-cmake ..
-sudo make install .
+cmake -DCMAKE_INSTALL_PREFIX:PATH=${PREFIX} -DCMAKE_BUILD_TYPE:STRING=Release -DBUILD_GUI=ON ..
+make install
diff --git a/recipe/meta.yaml b/recipe/meta.yaml
index bbb1bf5..3a35823 100644
--- a/recipe/meta.yaml
+++ b/recipe/meta.yaml
@@ -1,3 +1,24 @@
+#*******************************************************************************
+# libovnif/recipe/meta.yaml
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
 {% set name = "libonvif" %}
 {% set version = "1.2.0" %}
 
@@ -13,14 +34,17 @@ build:
 
 requirements:
   build:
-    - cmake  # [win]
+    - {{ compiler('cxx') }}
+    - cmake
     - make  # [unix]
-    - {{ compiler('c') }}
-    - libxml2
   host:
-    - libxml2
+    - libxml2=2.10.2 # [win]
+    - libxml2 # [linux]
+    - qt
   run:
-    - libxml2
+    - libxml2=2.10.2 # [win]
+    - libxml2 # [linux]
+    - qt
 
 test:
   commands:
diff --git a/sample/.vscode/c_cpp_properties.json b/sample/.vscode/c_cpp_properties.json
new file mode 100644
index 0000000..ff9c405
--- /dev/null
+++ b/sample/.vscode/c_cpp_properties.json
@@ -0,0 +1,17 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**",
+                "/home/stephen/anaconda3/envs/sample/include/qt/QtCore"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/gcc",
+            "cStandard": "gnu17",
+            "cppStandard": "gnu++17",
+            "intelliSenseMode": "linux-gcc-x64"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff --git a/sample/CMakeLists.txt b/sample/CMakeLists.txt
new file mode 100644
index 0000000..7c8af07
--- /dev/null
+++ b/sample/CMakeLists.txt
@@ -0,0 +1,97 @@
+#*******************************************************************************
+# libonvif/sample/CMakeLists.txt
+#
+# Copyright (c) 2020 Stephen Rhodes 
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#******************************************************************************/
+
+cmake_minimum_required(VERSION 3.17)
+
+project(discover)
+
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD_REQUIRED True)
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_AUTORCC ON)
+set(CMAKE_AUTOUIC ON)
+
+list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../cmake)
+
+find_package(Qt5 COMPONENTS Widgets REQUIRED)
+if (Qt5_FOUND)
+    message("-- Found Qt")
+endif()
+
+find_package(LibXml2)
+if (NOT LibXml2_FOUND)
+    message("-- Looking for installation of libxml2")
+    find_path(LIBXML2_INCLUDE_DIRS libxml/parser.h
+        HINTS
+            $ENV{CONDA_PREFIX}/Library/include/libxml2
+    )
+    find_library(LIBXML2_LIBRARIES NAMES xml2
+        HINTS
+            $ENV{CONDA_PREFIX}/lib
+    )
+    message("-- Found LIBXML2_INCLUDE_DIRS ${LIBXML2_INCLUDE_DIRS}")
+    message("-- Found LIBXML2_LIBRARIES ${LIBXML2_LIBRARIES}")
+endif()
+
+find_package(LibOnvif)
+if (LibOnvif_FOUND)
+    message("-- Found LIBONVIF_INCLUDE_DIRS ${LIBONVIF_INCLUDE_DIRS}")
+    message("-- Found LIBONVIF_LIBRARIES ${LIBONVIF_LIBRARIES}")
+endif()
+
+find_package(Iconv)
+if (NOT Iconv_FOUND)
+    message("--Could not find Iconv. If you are using libxml2 compiled without iconv, this message may be ignored")
+endif()
+
+add_executable(onvif
+    admintab.cpp
+    camera.cpp
+    cameradialogtab.cpp
+    cameralistmodel.cpp
+    cameralistview.cpp
+    camerapanel.cpp
+    configtab.cpp
+    discovery.cpp
+    imagetab.cpp
+    logindialog.cpp
+    main.cpp
+    mainwindow.cpp
+    networktab.cpp
+    onvifmanager.cpp
+    ptztab.cpp
+    videotab.cpp
+)
+
+target_link_libraries(onvif PRIVATE
+    Qt5::Widgets
+    ${LIBONVIF_LIBRARIES}
+    ${LIBXML2_LIBRARIES}
+    ${Iconv_LIBRARY}
+)
+
+target_include_directories(onvif PUBLIC
+    ${LIBONVIF_INCLUDE_DIRS}
+    ${LIBXML2_INCLUDE_DIRS}
+    ${Iconv_INCLUDE_DIR}
+)
+
diff --git a/sample/admintab.cpp b/sample/admintab.cpp
new file mode 100644
index 0000000..42cc218
--- /dev/null
+++ b/sample/admintab.cpp
@@ -0,0 +1,204 @@
+/*******************************************************************************
+* admintab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "camerapanel.h"
+
+#include <QGridLayout>
+#include <QLabel>
+#include <QMessageBox>
+#include <QProcess>
+#include <QThreadPool>
+#include <iostream>
+
+AdminTab::AdminTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    textCameraName = new QLineEdit();
+    textCameraName->setMaximumWidth(240);
+    textAdminPassword = new QLineEdit();
+    textAdminPassword->setMaximumWidth(240);
+    buttonReboot = new QPushButton(tr("Reboot Camera"), this);
+    buttonReboot->setMaximumWidth(160);
+    buttonReboot->setEnabled(false);
+    buttonSyncTime = new QPushButton(tr("Sync Time"), this);
+    buttonSyncTime->setMaximumWidth(100);
+    buttonLaunchBrowser = new QPushButton(tr("Browser"), this);
+    buttonLaunchBrowser->setMaximumWidth(100);
+    buttonHardReset = new QPushButton(tr("Hard Reset"), this);
+    buttonHardReset->setMaximumWidth(160);
+    buttonHardReset->setEnabled(false);
+    checkEnableReboot = new QCheckBox("Enable Reboot");
+    checkEnableReset = new QCheckBox("Enable Reset");
+
+    lblCameraName = new QLabel("Camera Name");
+    lblAdminPassword = new QLabel("Set admin Password");
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(lblCameraName,        0, 0, 1, 1);
+    layout->addWidget(textCameraName,       0, 1, 1, 2);
+    layout->addWidget(lblAdminPassword,     1, 0, 1, 1);
+    layout->addWidget(textAdminPassword,    1, 1, 1, 2);
+    layout->addWidget(buttonReboot,         2, 0, 1, 1);
+    layout->addWidget(buttonSyncTime,       2, 1, 1, 1);
+    layout->addWidget(buttonHardReset,      2, 2, 1, 1);
+    layout->addWidget(checkEnableReboot,    3, 0, 1, 1);
+    layout->addWidget(buttonLaunchBrowser,  3, 1, 1, 1);
+    layout->addWidget(checkEnableReset,     3, 2, 1, 1);
+    setLayout(layout);
+
+    connect(buttonLaunchBrowser, SIGNAL(clicked()), this, SLOT(launchBrowserClicked()));
+    connect(checkEnableReboot, SIGNAL(clicked()), this, SLOT(enableRebootChecked()));
+    connect(checkEnableReset, SIGNAL(clicked()), this, SLOT(enableResetChecked()));
+    connect(buttonReboot, SIGNAL(clicked()), this, SLOT(rebootClicked()));
+    connect(buttonHardReset, SIGNAL(clicked()), this, SLOT(hardResetClicked()));
+    connect(buttonSyncTime, SIGNAL(clicked()), this, SLOT(syncTimeClicked()));
+    connect(textCameraName, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString&)));
+    connect(textAdminPassword, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString&)));
+
+    rebooter = new Rebooter(cameraPanel);
+    connect(rebooter, SIGNAL(done()), this, SLOT(doneRebooting()));
+    resetter = new Resetter(cameraPanel);
+    connect(resetter, SIGNAL(done()), this, SLOT(doneResetting()));
+    timesetter = new Timesetter(cameraPanel);
+}
+
+void AdminTab::update()
+{
+    OnvifData *onvif_data = CP->camera->onvif_data;
+    QString camera_name = textCameraName->text();
+    strncpy(onvif_data->camera_name, camera_name.toLatin1(), camera_name.length());
+    onvif_data->camera_name[camera_name.length()] = '\0';
+    setUser(textAdminPassword->text().toLatin1().data(), onvif_data);
+    CP->applyButton->setEnabled(false);
+    CP->refreshList();
+    CP->cameraNames->setValue(onvif_data->serial_number, onvif_data->camera_name);
+    QString password = textAdminPassword->text();
+    strncpy(onvif_data->password, password.toLatin1(), password.length());
+}
+
+void AdminTab::clear()
+{
+    textCameraName->setText("");
+    textAdminPassword->setText("");
+    checkEnableReboot->setChecked(false);
+    checkEnableReset->setChecked(false);
+}
+
+void AdminTab::setActive(bool active)
+{
+    textCameraName->setEnabled(active);
+    textAdminPassword->setEnabled(active);
+    buttonLaunchBrowser->setEnabled(active);
+    buttonSyncTime->setEnabled(active);
+    checkEnableReboot->setEnabled(active);
+    checkEnableReset->setEnabled(active);
+    lblCameraName->setEnabled(active);
+    lblAdminPassword->setEnabled(active);
+}
+
+bool AdminTab::hasBeenEdited()
+{
+    bool result = false;
+
+    OnvifData *onvif_data = CP->camera->onvif_data;
+    QString camera_name = onvif_data->camera_name;
+    if (camera_name != textCameraName->text())
+        result = true;
+
+    if (textAdminPassword->text().length() > 0)
+        result = true;
+
+    return result;
+}
+
+void AdminTab::initialize()
+{
+    OnvifData *onvif_data = CP->camera->onvif_data;
+    textCameraName->setText(tr(onvif_data->camera_name));
+    buttonReboot->setEnabled(false);
+    buttonHardReset->setEnabled(false);
+    checkEnableReboot->setChecked(false);
+    checkEnableReset->setChecked(false);
+}
+
+void AdminTab::launchBrowserClicked()
+{
+    OnvifData *onvif_data = CP->camera->onvif_data;
+    char host[128];
+    extractHost(onvif_data->xaddrs, host);
+#ifdef _WIN32
+    QString cmd("\"C:\\Program Files\\Internet Explorer\\iexplore.exe\"");
+#else
+    QString cmd("xdg-open");
+#endif 
+    QStringList args = { QString("http://") + host};
+    process.start(cmd, args);
+}
+
+void AdminTab::enableRebootChecked()
+{
+    buttonReboot->setEnabled(checkEnableReboot->isChecked());
+}
+
+void AdminTab::enableResetChecked()
+{
+    buttonHardReset->setEnabled(checkEnableReset->isChecked());
+}
+
+void AdminTab::rebootClicked()
+{
+    QMessageBox::StandardButton result = QMessageBox::question(this, "playqt", "You are about to reboot the camera\nAre you sure you want to do this");
+    if (result == QMessageBox::Yes)
+        QThreadPool::globalInstance()->tryStart(rebooter);
+}
+
+void AdminTab::hardResetClicked()
+{
+    QMessageBox::StandardButton result = QMessageBox::question(this, "playqt", "You are about to HARD RESET the camera\nAll settings will be returned to default factory configuration\nAre you sure you want to do this");
+    if (result == QMessageBox::Yes)
+        QThreadPool::globalInstance()->tryStart(resetter);
+}
+
+void AdminTab::syncTimeClicked()
+{
+    QThreadPool::globalInstance()->tryStart(timesetter);
+}
+
+void AdminTab::doneRebooting()
+{
+    buttonReboot->setEnabled(false);
+    checkEnableReboot->setChecked(false);
+}
+
+void AdminTab::doneResetting()
+{
+    buttonHardReset->setEnabled(false);
+    checkEnableReset->setChecked(false);
+}
+
+void AdminTab::onTextChanged(const QString &)
+{
+    if (hasBeenEdited())
+        CP->applyButton->setEnabled(true);
+    else
+        CP->applyButton->setEnabled(false);
+}
diff --git a/sample/admintab.h b/sample/admintab.h
new file mode 100644
index 0000000..ea1ac97
--- /dev/null
+++ b/sample/admintab.h
@@ -0,0 +1,81 @@
+/*******************************************************************************
+* admintab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef ADMINTAB_H
+#define ADMINTAB_H
+
+#include "cameradialogtab.h"
+#include "onvifmanager.h"
+
+#include <QLineEdit>
+#include <QPushButton>
+#include <QCheckBox>
+#include <QLabel>
+#include <QProcess>
+
+class AdminTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    AdminTab(QWidget *parent);
+
+    QLineEdit *textCameraName;
+    QLineEdit *textAdminPassword;
+    QPushButton *buttonReboot;
+    QPushButton *buttonHardReset;
+    QPushButton *buttonLaunchBrowser;
+    QPushButton *buttonSyncTime;
+    QCheckBox *checkEnableReboot;
+    QCheckBox *checkEnableReset;
+
+    QLabel *lblCameraName;
+    QLabel *lblAdminPassword;
+
+    QWidget *cameraPanel;
+
+    Rebooter *rebooter;
+    Resetter *resetter;
+    Timesetter *timesetter;
+
+    QProcess process;
+
+    void update() override;
+    void clear() override;
+    void setActive(bool active) override;
+    bool hasBeenEdited()override;
+    void initialize();
+
+public slots:
+    void doneRebooting();
+    void doneResetting();
+
+private slots:
+    void launchBrowserClicked();
+    void enableRebootChecked();
+    void enableResetChecked();
+    void rebootClicked();
+    void hardResetClicked();
+    void syncTimeClicked();
+    void onTextChanged(const QString &);
+};
+
+#endif // ADMINTAB_H
diff --git a/sample/camera.cpp b/sample/camera.cpp
new file mode 100644
index 0000000..80ea167
--- /dev/null
+++ b/sample/camera.cpp
@@ -0,0 +1,45 @@
+/*******************************************************************************
+* camera.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "camera.h"
+
+Camera::Camera(OnvifData *arg)
+{
+    onvif_data = arg;
+}
+
+Camera::~Camera()
+{
+    free(onvif_data);
+}
+
+QString Camera::getCameraName()
+{
+    return QString(onvif_data->camera_name);
+}
+
+bool Camera::hasPTZ()
+{
+    if (strcmp(onvif_data->ptz_service, "") == 0)
+        return false;
+    else
+        return true;
+}
diff --git a/sample/camera.h b/sample/camera.h
new file mode 100644
index 0000000..964a203
--- /dev/null
+++ b/sample/camera.h
@@ -0,0 +1,43 @@
+/*******************************************************************************
+* camera.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef CAMERA_H
+#define CAMERA_H
+
+#include "onvif.h"
+#include <QObject>
+
+class Camera : public QObject
+{
+    Q_OBJECT
+
+public:
+    Camera(OnvifData *arg);
+    ~Camera();
+
+    QString getCameraName();
+    bool hasPTZ();
+
+    OnvifData *onvif_data;
+    bool onvif_data_read = false;
+};
+
+#endif // CAMERA_H
diff --git a/sample/cameradialogtab.cpp b/sample/cameradialogtab.cpp
new file mode 100644
index 0000000..8549d2e
--- /dev/null
+++ b/sample/cameradialogtab.cpp
@@ -0,0 +1,47 @@
+/*******************************************************************************
+* cameradialogtab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "cameradialogtab.h"
+
+CameraDialogTab::CameraDialogTab()
+{
+
+}
+
+void CameraDialogTab::update()
+{
+
+}
+
+void CameraDialogTab::clear()
+{
+
+}
+
+void CameraDialogTab::setActive(bool active)
+{
+
+}
+
+bool CameraDialogTab::hasBeenEdited()
+{
+    return false;
+}
diff --git a/sample/cameradialogtab.h b/sample/cameradialogtab.h
new file mode 100644
index 0000000..cdd148e
--- /dev/null
+++ b/sample/cameradialogtab.h
@@ -0,0 +1,42 @@
+/*******************************************************************************
+* cameradialogtab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef CAMERADIALOGTAB_H
+#define CAMERADIALOGTAB_H
+
+#include <QObject>
+#include <QWidget>
+
+class CameraDialogTab : public QWidget
+{
+    Q_OBJECT
+
+public:
+    CameraDialogTab();
+
+    virtual void update();
+    virtual void clear();
+    virtual void setActive(bool active);
+    virtual bool hasBeenEdited();
+
+};
+
+#endif // CAMERADIALOGTAB_H
diff --git a/sample/cameralistmodel.cpp b/sample/cameralistmodel.cpp
new file mode 100644
index 0000000..07d2c05
--- /dev/null
+++ b/sample/cameralistmodel.cpp
@@ -0,0 +1,108 @@
+/*******************************************************************************
+* cameralistmodel.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "cameralistmodel.h"
+#include "mainwindow.h"
+
+CameraListModel::CameraListModel(QMainWindow *parent)
+{
+    mainWindow = parent;
+}
+
+int CameraListModel::rowCount(const QModelIndex &parent) const
+{
+    Q_UNUSED(parent)
+    return cameras.size();
+}
+
+QVariant CameraListModel::data(const QModelIndex &index, int role) const
+{
+    if (index.isValid() && (role == Qt::DisplayRole || role == Qt::EditRole)) {
+        Camera *tmp = (Camera *)cameras[index.row()];
+        return tmp->getCameraName();
+    }
+    return QVariant();
+}
+
+bool CameraListModel::setData(const QModelIndex &index, const QVariant &value, int role)
+{
+    if (index.isValid() && role == Qt::EditRole) {
+        Camera *camera = (Camera *)cameras[index.row()];
+        strncpy(camera->onvif_data->camera_name, value.toString().toLatin1(), value.toString().length());
+        camera->onvif_data->camera_name[value.toString().length()] = '\0';
+        MW->cameraPanel->adminTab->textCameraName->setText(camera->onvif_data->camera_name);
+        MW->cameraPanel->cameraNames->setValue(camera->onvif_data->serial_number, camera->onvif_data->camera_name);
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+Qt::ItemFlags CameraListModel::flags(const QModelIndex &index) const
+{
+    return Qt::ItemIsEditable | QAbstractListModel::flags(index);
+}
+
+void CameraListModel::beginInsertItems(int start, int end)
+{
+    beginInsertRows(QModelIndex(), start, end);
+}
+
+void CameraListModel::endInsertItems()
+{
+    endInsertRows();
+}
+
+void CameraListModel::pushCamera(OnvifData *onvif_data)
+{
+    bool found = false;
+    for (int i = 0; i < cameras.size(); i++) {
+        if (!strcmp(onvif_data->xaddrs, cameras[i]->onvif_data->xaddrs))
+            found = true;
+    }
+    if (!found) {
+        Camera *camera = new Camera(onvif_data);
+        cameras.push_back(camera);
+        emit dataChanged(QModelIndex(), QModelIndex());
+    }
+}
+
+Camera * CameraListModel::getCameraAt(int index)
+{
+    return cameras[index];
+}
+
+void CameraListModel::onSelectedItemsChanged(QItemSelection selected, QItemSelection deselected)
+{
+    Q_UNUSED(deselected)
+    if (!selected.empty()) {
+        int index = selected.first().indexes().first().row();
+        Camera *camera = cameras[index];
+        MW->cameraPanel->camera = camera;
+        if (camera->onvif_data_read) {
+            emit showCameraData();
+        }
+        else {
+            emit getCameraData();
+        }
+    }
+}
diff --git a/sample/cameralistmodel.h b/sample/cameralistmodel.h
new file mode 100644
index 0000000..c61ca1b
--- /dev/null
+++ b/sample/cameralistmodel.h
@@ -0,0 +1,62 @@
+/*******************************************************************************
+* cameralistmodel.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef LISTMODEL_H
+#define LISTMODEL_H
+
+#include "camera.h"
+#include <list>
+#include <QVector>
+#include <QAbstractListModel>
+#include <QItemSelection>
+#include <QMainWindow>
+
+class CameraListModel : public QAbstractListModel
+{
+    Q_OBJECT
+
+public:
+    CameraListModel(QMainWindow *parent);
+    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
+    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
+    bool setData(const QModelIndex &index, const QVariant &value, int rolw = Qt::EditRole) override;
+    Qt::ItemFlags flags(const QModelIndex &index) const override;
+    void pushCamera(OnvifData *onvif_data);
+    Camera * getCameraAt(int index);
+    int current_index = -1;
+    QVector<Camera *> cameras;
+    QMainWindow *mainWindow;
+
+signals:
+    void getCameraData();
+    void showCameraData();
+
+public slots:
+    void onSelectedItemsChanged(QItemSelection selected, QItemSelection deselected);
+
+private slots:
+    void beginInsertItems(int start, int end);
+    void endInsertItems();
+
+
+};
+
+#endif // LISTMODEL_H
diff --git a/sample/cameralistview.cpp b/sample/cameralistview.cpp
new file mode 100644
index 0000000..8e4b737
--- /dev/null
+++ b/sample/cameralistview.cpp
@@ -0,0 +1,100 @@
+/*******************************************************************************
+* cameralistview.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "cameralistview.h"
+#include "mainwindow.h"
+#include <QMouseEvent>
+
+CameraListView::CameraListView(QMainWindow *parent)
+{
+    mainWindow = parent;
+    cameraListModel = new CameraListModel(mainWindow);
+    setModel(cameraListModel);
+    setFrameStyle(QFrame::Panel | QFrame::Sunken);
+    connect(selectionModel(), SIGNAL(selectionChanged(QItemSelection, QItemSelection)), cameraListModel, SLOT(onSelectedItemsChanged(QItemSelection, QItemSelection)));
+}
+
+void CameraListView::mouseDoubleClickEvent(QMouseEvent *event)
+{
+    Q_UNUSED(event);
+}
+
+QModelIndex CameraListView::previousIndex() const
+{
+    QModelIndex previous;
+    QModelIndex index = currentIndex();
+    if (index.isValid()) {
+        if (index.row() > 0) {
+            QRect rect = rectForIndex(index);
+            QPoint previous_center = QPoint(rect.center().x(), rect.center().y() - rect.height());
+            previous = indexAt(previous_center);
+        }
+    }
+    return previous;
+}
+
+QModelIndex CameraListView::nextIndex() const
+{
+    QModelIndex next;
+    QModelIndex index = currentIndex();
+    if (index.isValid()) {
+        if (index.row() + 1 < model()->rowCount()) {
+            QRect rect = rectForIndex(index);
+            QPoint next_center = QPoint(rect.center().x(), rect.center().y() + rect.height());
+            next = indexAt(next_center);
+        }
+    }
+    return next;
+}
+
+void CameraListView::setCurrentCamera(const QString& cameraName)
+{
+    int row = -1;
+    for (int i = 0; i < model()->rowCount(); i++) {
+        Camera *camera = ((CameraListModel*)model())->getCameraAt(i);
+        if (camera->getCameraName() == cameraName) {
+            row = i;
+            break;
+        }
+    }
+
+    if (row > -1) {
+        QModelIndex index = model()->index(row, 0);
+        setCurrentIndex(index);
+    }
+}
+
+Camera *CameraListView::getCurrentCamera()
+{
+    if (currentIndex().isValid())
+        return (Camera*)((CameraListModel*)model())->cameras[currentIndex().row()];
+    else
+        return NULL;
+}
+
+void CameraListView::refresh()
+{
+    for (int i = 0; i < model()->rowCount(); i++) {
+        Camera *camera = ((CameraListModel*)model())->getCameraAt(i);
+    }
+    model()->emit dataChanged(QModelIndex(), QModelIndex());
+}
+
diff --git a/sample/cameralistview.h b/sample/cameralistview.h
new file mode 100644
index 0000000..43b8c13
--- /dev/null
+++ b/sample/cameralistview.h
@@ -0,0 +1,53 @@
+/*******************************************************************************
+* cameralistview.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef LISTVIEW_H
+#define LISTVIEW_H
+
+#include "camera.h"
+#include "cameralistmodel.h"
+#include <QListView>
+#include <QMouseEvent>
+#include <QMainWindow>
+
+class CameraListView : public QListView
+{
+    Q_OBJECT
+
+public:
+    CameraListView(QMainWindow *parent);
+    Camera *getCurrentCamera();
+    void setCurrentCamera(const QString& cameraName);
+    void refresh();
+    QModelIndex previousIndex() const;
+    QModelIndex nextIndex() const;
+
+    void mouseDoubleClickEvent(QMouseEvent *event) override;
+
+    QMainWindow *mainWindow;
+    CameraListModel *cameraListModel;
+    QModelIndex index;
+
+signals:
+    void connectToCamera(QModelIndex);
+};
+
+#endif // LISTVIEW_H
diff --git a/sample/camerapanel.cpp b/sample/camerapanel.cpp
new file mode 100644
index 0000000..42144e8
--- /dev/null
+++ b/sample/camerapanel.cpp
@@ -0,0 +1,250 @@
+/*******************************************************************************
+* camerapanel.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <sstream>
+#include "camerapanel.h"
+#include "mainwindow.h"
+#include <QGridLayout>
+#include <QThreadPool>
+#include <QDialogButtonBox>
+
+CameraPanel::CameraPanel(QMainWindow *parent)
+{
+    mainWindow = parent;
+
+    tabWidget = new QTabWidget();
+    videoTab = new VideoTab(this);
+    tabWidget->addTab(videoTab, "Video");
+    imageTab = new ImageTab(this);
+    tabWidget->addTab(imageTab, "Image");
+    networkTab = new NetworkTab(this);
+    tabWidget->addTab(networkTab, "Network");
+    ptzTab = new PTZTab(this);
+    tabWidget->addTab(ptzTab, "PTZ");
+    adminTab = new AdminTab(this);
+    tabWidget->addTab(adminTab, "Admin");
+    configTab = new ConfigTab(this);
+    tabWidget->addTab(configTab, "Config");
+    tabWidget->setMaximumHeight(220);
+
+    applyButton = new QPushButton(tr("Apply"), this);
+    connect(applyButton, SIGNAL(clicked()), this, SLOT(applyButtonClicked()));
+    discoverButton = new QPushButton("Discover", this);
+    connect(discoverButton, SIGNAL(clicked()), this, SLOT(discoverButtonClicked()));
+    viewButton = new QPushButton("View", this);
+    connect(viewButton, SIGNAL(clicked()), this, SLOT(viewButtonClicked()));
+
+    QDialogButtonBox *buttonBox = new QDialogButtonBox(Qt::Horizontal, this);
+    buttonBox->addButton(discoverButton, QDialogButtonBox::ActionRole);
+    buttonBox->addButton(viewButton, QDialogButtonBox::ActionRole);
+    buttonBox->addButton(applyButton, QDialogButtonBox::ActionRole);
+    buttonBox->setMaximumHeight(60);
+
+    cameraList = new CameraListView(mainWindow);
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(cameraList,   0, 0, 1, 1);
+    layout->addWidget(tabWidget,    1, 0, 1, 1);
+    layout->addWidget(buttonBox,    2, 0, 1, 1);
+    layout->setColumnStretch(0, 10);
+    setLayout(layout);
+
+    filler = new Filler(this);
+    connect(filler, SIGNAL(done()), this, SLOT(showData()));
+
+    videoTab->setActive(false);
+    imageTab->setActive(false);
+    networkTab->setActive(false);
+    ptzTab->setActive(false);
+    adminTab->setActive(false);
+    applyButton->setEnabled(false);
+    viewButton->setEnabled(false);
+
+    connect(this, SIGNAL(msg(QString)), mainWindow, SLOT(msg(QString)));
+
+    CameraListModel *cameraListModel = cameraList->cameraListModel;
+    connect(cameraListModel, SIGNAL(showCameraData()), this, SLOT(showData()));
+    connect(cameraListModel, SIGNAL(getCameraData()), this, SLOT(fillData()));
+
+    configTab->commonUsername->setText(MW->settings->value(usernameKey, "").toString());
+    configTab->commonPassword->setText(MW->settings->value(passwordKey, "").toString());
+    configTab->player->setText(MW->settings->value(playerKey, "ffplay").toString());
+    configTab->autoDiscovery->setChecked(MW->settings->value(autoDiscKey, false).toBool());
+    configTab->multiBroadcast->setChecked(MW->settings->value(multiBroadKey, false).toBool());
+    configTab->broadcastRepeat->setValue(MW->settings->value(broadRepKey, 2).toInt());
+    configTab->autoDiscoveryClicked(configTab->autoDiscovery->isChecked());
+
+    savedAutoCameraName = MW->settings->value(autoCameraKey, "").toString();
+    onvif_session = (OnvifSession*)malloc(sizeof(OnvifSession));
+    initializeSession(onvif_session);
+    discovery = new Discovery(this);
+    connect(discovery, SIGNAL(stopping()), this, SLOT(discoveryFinished()));
+    cameraNames = new QSettings("Onvif", "Camera Names");
+    foreach(QString key, cameraNames->allKeys()) {
+        discovery->cameraAlias.insert(key, cameraNames->value(key).toString());
+    }
+
+    if (configTab->autoDiscovery->isChecked()) {
+        discovery->start();
+    }
+}
+
+CameraPanel::~CameraPanel()
+{
+    closeSession(onvif_session);
+    free(onvif_session);
+}
+
+void CameraPanel::receiveOnvifData(OnvifData *onvif_data)
+{
+    cameraList->cameraListModel->pushCamera(onvif_data);
+}
+
+void CameraPanel::discoverButtonClicked()
+{
+    discovery->start();
+}
+
+void CameraPanel::viewButtonClicked()
+{
+    std::stringstream ss_uri;
+    OnvifData* onvif_data = cameraList->getCurrentCamera()->onvif_data;
+	std::string uri(onvif_data->stream_uri);
+	ss_uri << uri.substr(0, 7) << onvif_data->username << ":" << onvif_data->password << "@" << uri.substr(7);
+    uri = ss_uri.str();
+
+    std::string player(configTab->player->text().toLatin1().data());
+    
+    QString cmd(QString(player.c_str()));
+    QStringList args = { QString(uri.c_str()) };
+    process.start(cmd, args);
+}
+
+void CameraPanel::showLoginDialog(Credential *credential)
+{
+    if (loginDialog == nullptr)
+        loginDialog = new LoginDialog(this);
+
+    loginDialog->cameraName->setText(QString("Camera Name: ").append(credential->camera_name));
+    if (loginDialog->exec()) {
+        QString username = loginDialog->username->text();
+        strncpy(credential->username, username.toLatin1(), username.length());
+        QString password = loginDialog->password->text();
+        strncpy(credential->password, password.toLatin1(), password.length());
+        credential->accept_requested = true;
+    }
+    else {
+        emit msg("login cancelled");
+        memset(credential->username, 0, 128);
+        memset(credential->password, 0, 128);
+        credential->accept_requested = false;
+    }
+    discovery->resume();
+}
+
+void CameraPanel::applyButtonClicked()
+{
+    CameraDialogTab *tab = (CameraDialogTab *)tabWidget->currentWidget();
+    tab->update();
+}
+
+void CameraPanel::fillData()
+{
+    videoTab->clear();
+    imageTab->clear();
+    networkTab->clear();
+    adminTab->clear();
+    videoTab->setActive(false);
+    imageTab->setActive(false);
+    networkTab->setActive(false);
+    adminTab->setActive(false);
+    applyButton->setEnabled(false);
+    viewButton->setEnabled(false);
+    QThreadPool::globalInstance()->tryStart(filler);
+}
+
+void CameraPanel::showData()
+{
+    videoTab->initialize();
+    imageTab->initialize();
+    networkTab->initialize();
+    adminTab->initialize();
+
+    videoTab->setActive(true);
+    imageTab->setActive(true);
+    networkTab->setActive(true);
+    adminTab->setActive(true);
+    ptzTab->setActive(camera->hasPTZ());
+    camera->onvif_data_read = true;
+    applyButton->setEnabled(false);   
+    viewButton->setEnabled(true);
+}
+
+void CameraPanel::saveUsername()
+{
+    MW->settings->setValue(usernameKey, configTab->commonUsername->text());
+}
+
+void CameraPanel::savePassword()
+{
+    MW->settings->setValue(passwordKey, configTab->commonPassword->text());
+}
+
+void CameraPanel::savePlayer()
+{
+    MW->settings->setValue(playerKey, configTab->player->text());
+}
+
+void CameraPanel::saveAutoDiscovery()
+{
+    MW->settings->setValue(autoDiscKey, configTab->autoDiscovery->isChecked());
+}
+
+void CameraPanel::saveMultiBroadcast()
+{
+    MW->settings->setValue(multiBroadKey, configTab->multiBroadcast->isChecked());
+}
+
+void CameraPanel::saveBroadcastRepeat(int value)
+{
+    MW->settings->setValue(broadRepKey, value);
+}
+
+void CameraPanel::saveNetIntf(const QString& name)
+{
+    MW->settings->setValue(netIntfKey, name);
+}
+
+void CameraPanel::autoLoadClicked(bool checked)
+{
+    MW->settings->setValue(autoLoadKey, checked);
+}
+
+void CameraPanel::discoveryFinished()
+{
+    emit msg("discovery is completed");
+}
+
+void CameraPanel::refreshList()
+{
+    cameraList->refresh();
+}
+
diff --git a/sample/camerapanel.h b/sample/camerapanel.h
new file mode 100644
index 0000000..773fe7c
--- /dev/null
+++ b/sample/camerapanel.h
@@ -0,0 +1,113 @@
+/*******************************************************************************
+* camerapanel.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef CAMERAPANEL_H
+#define CAMERAPANEL_H
+
+#include "videotab.h"
+#include "imagetab.h"
+#include "networktab.h"
+#include "ptztab.h"
+#include "admintab.h"
+#include "configtab.h"
+#include "onvifmanager.h"
+#include "camera.h"
+#include "cameralistview.h"
+#include "discovery.h"
+#include "logindialog.h"
+
+#include <QObject>
+#include <QDialog>
+#include <QTabWidget>
+#include <QPushButton>
+#include <QMainWindow>
+#include <QSettings>
+
+#define CP dynamic_cast<CameraPanel*>(cameraPanel)
+
+class CameraPanel : public QWidget
+{
+    Q_OBJECT
+
+public:
+    CameraPanel(QMainWindow *parent);
+    ~CameraPanel();
+    void refreshList();
+    void saveUsername();
+    void savePassword();
+    void savePlayer();
+    void saveAutoDiscovery();
+    void saveMultiBroadcast();
+    void saveNetIntf(const QString& name);
+    void autoLoadClicked(bool checked);
+    void autoCameraChanged(int index);
+    void saveBroadcastRepeat(int value);
+
+    Camera *camera;
+    QTabWidget *tabWidget;
+    QPushButton *applyButton;
+    QPushButton *discoverButton;
+    QPushButton *viewButton;
+    VideoTab *videoTab;
+    ImageTab *imageTab;
+    NetworkTab *networkTab;
+    PTZTab *ptzTab;
+    AdminTab *adminTab;
+    ConfigTab *configTab;
+    QMainWindow *mainWindow;
+    Filler *filler;
+    CameraListView *cameraList;
+    Discovery *discovery;
+    LoginDialog *loginDialog = nullptr;
+    QSettings *cameraNames;
+    OnvifSession *onvif_session;
+
+    const QString usernameKey   = "CameraPanel/username";
+    const QString passwordKey   = "CameraPanel/password";
+    const QString playerKey     = "CameraPanel/player";
+    const QString autoDiscKey   = "CameraPanel/autoDiscovery";
+    const QString multiBroadKey = "CameraPanel/multiBroadcast";
+    const QString broadRepKey   = "CameraPanel/brodacastRepeat";
+    const QString netIntfKey    = "CameraPanel/networkInterface";
+    const QString autoLoadKey   = "CameraPanel/autoLoad";
+    const QString autoCameraKey = "CameraPanel/autoCamera";
+
+    QString savedAutoCameraName;
+    bool autoCameraFound;
+
+    QProcess process;
+
+signals:
+    void msg(QString str);
+
+public slots:
+    void fillData();
+    void showData();
+    void receiveOnvifData(OnvifData*);
+    void showLoginDialog(Credential*);
+    void applyButtonClicked();
+    void discoverButtonClicked();
+    void viewButtonClicked();
+    void discoveryFinished();
+
+};
+
+#endif // CAMERAPANEL_H
diff --git a/sample/configtab.cpp b/sample/configtab.cpp
new file mode 100644
index 0000000..c4bc672
--- /dev/null
+++ b/sample/configtab.cpp
@@ -0,0 +1,107 @@
+/*******************************************************************************
+* configtab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <QLabel>
+#include <QGridLayout>
+
+#include "configtab.h"
+#include "camerapanel.h"
+
+ConfigTab::ConfigTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    autoDiscovery = new QCheckBox("Auto Discovery");
+    multiBroadcast = new QCheckBox("Multi Broadcast");
+    player = new QLineEdit("ffplay");
+    player->setMaximumWidth(100);
+    QLabel *lbl03 = new QLabel("Player");
+    broadcastRepeat = new QSpinBox();
+    broadcastRepeat->setRange(2, 5);
+    QLabel *lbl00 = new QLabel("Broadcast Repeat");
+    commonUsername = new QLineEdit();
+    commonUsername->setMaximumWidth(100);
+    QLabel *lbl01 = new QLabel("Common Username");
+    commonPassword = new QLineEdit();
+    commonPassword->setMaximumWidth(100);
+    QLabel *lbl02 = new QLabel("Common Password");
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(autoDiscovery,       1, 0, 1, 1);
+    layout->addWidget(lbl03,               1, 1, 1, 1);
+    layout->addWidget(player,              1, 2, 1, 1);
+    layout->addWidget(multiBroadcast,      2, 0, 1, 1);
+    layout->addWidget(lbl00,               2, 1, 1 ,1);
+    layout->addWidget(broadcastRepeat,     2, 2, 1, 1);
+    layout->addWidget(lbl01,               3, 0, 1, 1);
+    layout->addWidget(commonUsername,      3, 1, 1, 1);
+    layout->addWidget(lbl02,               4, 0, 1, 1);
+    layout->addWidget(commonPassword,      4, 1, 1, 1);
+    setLayout(layout);
+
+    connect(commonUsername, SIGNAL(editingFinished()), this, SLOT(usernameUpdated()));
+    connect(commonPassword, SIGNAL(editingFinished()), this, SLOT(passwordUpdated()));
+    connect(player, SIGNAL(editingFinished()), this, SLOT(playerUpdated()));
+    connect(autoDiscovery, SIGNAL(clicked(bool)), this, SLOT(autoDiscoveryClicked(bool)));
+    connect(multiBroadcast, SIGNAL(clicked(bool)), this, SLOT(multiBroadcastClicked(bool)));
+    connect(broadcastRepeat, SIGNAL(valueChanged(int)), this, SLOT(broadcastRepeatChanged(int)));
+}
+
+void ConfigTab::autoDiscoveryClicked(bool checked)
+{
+    if (checked) {
+        multiBroadcast->setEnabled(true);
+        broadcastRepeat->setEnabled(true);
+    }
+    else {
+        multiBroadcast->setEnabled(false);
+        broadcastRepeat->setEnabled(false);
+        multiBroadcast->setChecked(false);
+    }
+    CP->saveAutoDiscovery();
+    CP->saveMultiBroadcast();
+}
+
+void ConfigTab::multiBroadcastClicked(bool checked)
+{
+    Q_UNUSED(checked);
+    CP->saveMultiBroadcast();
+}
+
+void ConfigTab::broadcastRepeatChanged(int value)
+{
+    CP->saveBroadcastRepeat(value);
+}
+
+void ConfigTab::usernameUpdated()
+{
+    CP->saveUsername();
+}
+
+void ConfigTab::passwordUpdated()
+{
+    CP->savePassword();
+}
+
+void ConfigTab::playerUpdated()
+{
+    CP->savePlayer();
+}
diff --git a/sample/configtab.h b/sample/configtab.h
new file mode 100644
index 0000000..a93462a
--- /dev/null
+++ b/sample/configtab.h
@@ -0,0 +1,63 @@
+/*******************************************************************************
+* configtab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef CONFIGTAB_H
+#define CONFIGTAB_H
+
+#include <QComboBox>
+#include <QLineEdit>
+#include <QPushButton>
+#include <QCheckBox>
+#include <QLabel>
+#include <QSpinBox>
+#include <QMainWindow>
+
+#include "cameradialogtab.h"
+
+class ConfigTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    ConfigTab(QWidget *parent);
+
+    QWidget *cameraPanel;
+    QCheckBox *autoDiscovery;
+    QCheckBox *multiBroadcast;
+    QSpinBox *broadcastRepeat;
+    QLineEdit *commonUsername;
+    QLineEdit *commonPassword;
+    QLineEdit* player;
+
+signals:
+    void msg(const QString&);
+
+public slots:
+    void usernameUpdated();
+    void passwordUpdated();
+    void playerUpdated();
+    void autoDiscoveryClicked(bool);
+    void multiBroadcastClicked(bool);
+    void broadcastRepeatChanged(int);
+
+};
+
+#endif // CONFIGTAB_H
diff --git a/sample/discovery.cpp b/sample/discovery.cpp
new file mode 100644
index 0000000..71e1e07
--- /dev/null
+++ b/sample/discovery.cpp
@@ -0,0 +1,207 @@
+/*******************************************************************************
+* discovery.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "discovery.h"
+#include "camerapanel.h"
+
+Discovery::Discovery(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    thread = new QThread;
+    moveToThread(thread);
+
+    connect(this, SIGNAL(starting()), thread, SLOT(start()));
+    connect(this, SIGNAL(stopping()), thread, SLOT(quit()));
+    connect(thread, SIGNAL(started()), this, SLOT(run()));
+
+    connect(this, SIGNAL(msg(QString)), CP->mainWindow, SLOT(msg(QString)));
+
+    running = false;
+
+    loginDialog = new LoginDialog(cameraPanel);
+    connect(this, SIGNAL(login(Credential*)), cameraPanel, SLOT(showLoginDialog(Credential*)));
+    connect(this, SIGNAL(found(OnvifData*)), cameraPanel, SLOT(receiveOnvifData(OnvifData*)));
+}
+
+Discovery::~Discovery()
+{
+    if (running)
+        stop();
+    thread->wait();
+}
+
+void Discovery::start()
+{
+    mutex.lock();
+    running = true;
+    mutex.unlock();
+    emit starting();
+}
+
+void Discovery::stop()
+{
+    mutex.lock();
+    running = false;
+    mutex.unlock();
+    emit stopping();
+}
+
+void Discovery::resume()
+{
+    waitCondition.wakeAll();
+}
+
+bool Discovery::isRunning()
+{
+    return running;
+}
+
+void Discovery::run()
+{
+    discover();
+}
+
+void Discovery::discover()
+{
+    int nb_loops = 1;
+    if (CP->configTab->multiBroadcast->isChecked())
+        nb_loops = CP->configTab->broadcastRepeat->value();
+
+    for (int k=0; k<nb_loops; k++) {
+        OnvifSession* onvif_session = ((CameraPanel*)cameraPanel)->onvif_session;
+        ConfigTab *configTab = CP->configTab;
+
+        QString str = "Discovery started\n";
+
+        int number_of_cameras = broadcast(onvif_session);
+        str.append(QString("libonvif found %1 cameras\n").arg(QString::number(number_of_cameras)));
+        emit msg(str);
+
+        for (int i=0; i<number_of_cameras; i++) {
+            if (running) {
+                OnvifData *onvif_data = (OnvifData*)malloc(sizeof(OnvifData));
+                memset(onvif_data, 0, sizeof(OnvifData));
+                prepareOnvifData(i, onvif_session, onvif_data);
+                emit msg(QString("Connecting to camera %1 at %2").arg(onvif_data->camera_name, onvif_data->xaddrs));
+                QString username = configTab->commonUsername->text();
+                QString password = configTab->commonPassword->text();
+                strncpy(onvif_data->username, username.toLatin1(), username.length());
+                strncpy(onvif_data->password, password.toLatin1(), password.length());
+
+                bool loggedIn = alreadyLoggedIn(onvif_data);
+                if (loggedIn) {
+                    emit msg(QString("Duplicate discovery packet for camera %1\n").arg(onvif_data->camera_name));
+                }
+
+                while (!loggedIn) {
+                    if (fillRTSP(onvif_data) == 0) {
+                        loggedIn = true;
+                        addCamera(onvif_data);
+                    }
+                    else {
+                        QString error_msg = onvif_data->last_error;
+                        if (error_msg.contains("ter:NotAuthorized") || error_msg.contains("Unauthorized")) {
+                            memset(&credential, 0, sizeof(credential));
+                            strncpy(credential.camera_name, onvif_data->camera_name,
+                                    sizeof(credential.camera_name)-1);
+                            emit login(&credential);
+
+                            emit msg("starting login");
+                            mutex.lock();
+                            waitCondition.wait(&mutex);
+                            mutex.unlock();
+
+                            if (credential.accept_requested) {
+                                strncpy(onvif_data->username, credential.username,
+                                        sizeof(onvif_data->username));
+                                onvif_data->username[sizeof(onvif_data->username)-1]=0;
+                                strncpy(onvif_data->password, credential.password,
+                                        sizeof(onvif_data->password));
+                                onvif_data->username[sizeof(onvif_data->password)-1]=0;
+
+                                if (fillRTSP(onvif_data) == 0) {
+                                    loggedIn = true;
+                                    addCamera(onvif_data);
+                                }
+                                else {
+                                    emit msg(QString("Login failure for camera %1\n").arg(onvif_data->camera_name));
+                                }
+                            }
+                            else {
+                                emit msg(QString("Login cancelled for camera %1\n").arg(onvif_data->camera_name));
+                                break;
+                            }
+                        }
+                        else {
+                            emit msg(QString("ONVIF error %1\n").arg(onvif_data->last_error));
+                            break;
+                        }
+                    }
+                }
+            }
+            else {
+                break;
+            }
+        }
+
+        thread->msleep((k+1) * 200);
+    }
+    stop();
+}
+
+void Discovery::addCamera(OnvifData *onvif_data)
+{
+    getProfile(onvif_data);
+    getDeviceInformation(onvif_data);
+
+    QString str;
+    str.append(QString("%1\n").arg(onvif_data->stream_uri));
+    str.append(QString("serial number: %1\nmfgr name: %2\n").arg(onvif_data->serial_number, onvif_data->camera_name));
+
+    QString key = onvif_data->serial_number;
+    QString alias = cameraAlias.value(key);
+    if (alias.length() > 0) {
+        strncpy(onvif_data->camera_name, alias.toLatin1().data(), alias.length());
+        onvif_data->camera_name[alias.length()] = '\0';
+    }
+
+    emit found(onvif_data);
+
+    str.append(QString("display name: %1\n").arg(onvif_data->camera_name));
+    emit msg(str);
+}
+
+bool Discovery::alreadyLoggedIn(OnvifData *onvif_data)
+{
+    bool result = false;
+
+    QVector<Camera *> cameras = CP->cameraList->cameraListModel->cameras;
+    for (int i = 0; i < cameras.size(); i++) {
+        Camera *camera = cameras[i];
+        QString currentXaddrs = onvif_data->xaddrs;
+        QString cameraXaddrs = camera->onvif_data->xaddrs;
+        if (currentXaddrs == cameraXaddrs)
+            result = true;
+    }
+
+    return result;
+}
diff --git a/sample/discovery.h b/sample/discovery.h
new file mode 100644
index 0000000..a815fc8
--- /dev/null
+++ b/sample/discovery.h
@@ -0,0 +1,75 @@
+/*******************************************************************************
+* discovery.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef DISCOVERY_H
+#define DISCOVERY_H
+
+#include "onvif.h"
+#include "logindialog.h"
+#include <QObject>
+#include <QMutex>
+#include <QThread>
+#include <QHash>
+#include <QMainWindow>
+#include <QWaitCondition>
+
+class Discovery : public QObject
+{
+    Q_OBJECT
+
+public:
+    Discovery(QWidget *parent);
+    ~Discovery();
+
+    void start();
+    void stop();
+    void resume();
+    void discover();
+    bool isRunning();
+    bool alreadyLoggedIn(OnvifData *onvif_data);
+    void addCamera(OnvifData *onvif_data);
+
+    QWidget *cameraPanel;
+    char *username;
+    char *password;
+    QHash<QString, QString> cameraAlias;
+    LoginDialog *loginDialog;
+    Credential credential;
+
+private:
+    bool running;
+    QThread *thread;
+    QMutex mutex;
+    QWaitCondition waitCondition;
+
+signals:
+    void starting();
+    void stopping();
+    void found(OnvifData *onvif_data);
+    void login(Credential*);
+    void msg(QString);
+
+public slots:
+    void run();
+
+};
+
+#endif // DISCOVERY_H
diff --git a/sample/imagetab.cpp b/sample/imagetab.cpp
new file mode 100644
index 0000000..cfeb1d1
--- /dev/null
+++ b/sample/imagetab.cpp
@@ -0,0 +1,145 @@
+/*******************************************************************************
+* imagetab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "camerapanel.h"
+
+#include <QGridLayout>
+#include <QLabel>
+#include <QThreadPool>
+
+ImageTab::ImageTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    sliderBrightness = new QSlider(Qt::Horizontal);
+    sliderSaturation = new QSlider(Qt::Horizontal);
+    sliderContrast = new QSlider(Qt::Horizontal);
+    sliderSharpness = new QSlider(Qt::Horizontal);
+
+    lblBrightness = new QLabel("Brightness");
+    lblSaturation = new QLabel("Saturation");
+    lblContrast = new QLabel("Contrast");
+    lblSharpness = new QLabel("Sharpness");
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(lblBrightness,     0, 0, 1, 1);
+    layout->addWidget(sliderBrightness,  0, 1, 1, 1);
+    layout->addWidget(lblSaturation,     1, 0, 1, 1);
+    layout->addWidget(sliderSaturation,  1, 1, 1, 1);
+    layout->addWidget(lblContrast,       2, 0, 1, 1);
+    layout->addWidget(sliderContrast,    2, 1, 1, 1);
+    layout->addWidget(lblSharpness,      3, 0, 1, 1);
+    layout->addWidget(sliderSharpness,   3, 1, 1, 1);
+    setLayout(layout);
+
+    connect(sliderBrightness, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+    connect(sliderSaturation, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+    connect(sliderContrast, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+    connect(sliderSharpness, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+
+    updater = new ImageUpdater(cameraPanel);
+    connect(updater, SIGNAL(done()), this, SLOT(initialize()));
+
+}
+
+void ImageTab::update()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    onvif_data->brightness = sliderBrightness->value();
+    onvif_data->saturation = sliderSaturation->value();
+    onvif_data->contrast = sliderContrast->value();
+    onvif_data->sharpness = sliderSharpness->value();
+    setImagingSettings(onvif_data);
+
+    QThreadPool::globalInstance()->tryStart(updater);
+}
+
+void ImageTab::clear()
+{
+    sliderBrightness->setMinimum(0);
+    sliderBrightness->setMaximum(0);
+    sliderSaturation->setMinimum(0);
+    sliderSaturation->setMaximum(0);
+    sliderContrast->setMinimum(0);
+    sliderContrast->setMaximum(0);
+    sliderSharpness->setMinimum(0);
+    sliderSharpness->setMaximum(0);
+
+    sliderBrightness->setValue(0);
+    sliderSaturation->setValue(0);
+    sliderContrast->setValue(0);
+    sliderSharpness->setValue(0);
+}
+
+void ImageTab::setActive(bool active)
+{
+    sliderBrightness->setEnabled(active);
+    sliderSaturation->setEnabled(active);
+    sliderContrast->setEnabled(active);
+    sliderSharpness->setEnabled(active);
+    lblBrightness->setEnabled(active);
+    lblSaturation->setEnabled(active);
+    lblContrast->setEnabled(active);
+    lblSharpness->setEnabled(active);
+}
+
+bool ImageTab::hasBeenEdited()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    bool result = false;
+    if (sliderBrightness->value() != onvif_data->brightness)
+        result = true;
+    if (sliderSaturation->value() != onvif_data->saturation)
+        result = true;
+    if (sliderContrast->value() != onvif_data->contrast)
+        result = true;
+    if (sliderSharpness->value() != onvif_data->sharpness)
+        result = true;
+    return result;
+}
+
+void ImageTab::initialize()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    sliderBrightness->setMinimum(onvif_data->brightness_min);
+    sliderBrightness->setMaximum(onvif_data->brightness_max);
+    sliderSaturation->setMinimum(onvif_data->saturation_min);
+    sliderSaturation->setMaximum(onvif_data->saturation_max);
+    sliderContrast->setMinimum(onvif_data->contrast_min);
+    sliderContrast->setMaximum(onvif_data->contrast_max);
+    sliderSharpness->setMinimum(onvif_data->sharpness_min);
+    sliderSharpness->setMaximum(onvif_data->sharpness_max);
+
+    sliderBrightness->setValue(onvif_data->brightness);
+    sliderSaturation->setValue(onvif_data->saturation);
+    sliderContrast->setValue(onvif_data->contrast);
+    sliderSharpness->setValue(onvif_data->sharpness);
+    ((CameraPanel *)cameraPanel)->applyButton->setEnabled(false);
+}
+
+void ImageTab::onValueChanged(int value)
+{
+    Q_UNUSED(value);
+    if (hasBeenEdited())
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(true);
+    else
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(false);
+}
diff --git a/sample/imagetab.h b/sample/imagetab.h
new file mode 100644
index 0000000..9ba1e45
--- /dev/null
+++ b/sample/imagetab.h
@@ -0,0 +1,64 @@
+/*******************************************************************************
+* imagetab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef IMAGETAB_H
+#define IMAGETAB_H
+
+#include "cameradialogtab.h"
+#include "onvifmanager.h"
+
+#include <QSlider>
+#include <QLabel>
+
+class ImageTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    ImageTab(QWidget *parent);
+
+    QSlider *sliderBrightness;
+    QSlider *sliderSaturation;
+    QSlider *sliderContrast;
+    QSlider *sliderSharpness;
+
+    QLabel *lblBrightness;
+    QLabel *lblSaturation;
+    QLabel *lblContrast;
+    QLabel *lblSharpness;
+
+    QWidget *cameraPanel;
+
+    ImageUpdater *updater;
+
+    void update() override;
+    void clear() override;
+    void setActive(bool active) override;
+    bool hasBeenEdited() override;
+
+public slots:
+    void initialize();
+
+private slots:
+    void onValueChanged(int value);
+};
+
+#endif // IMAGETAB_H
diff --git a/sample/logindialog.cpp b/sample/logindialog.cpp
new file mode 100644
index 0000000..b30f029
--- /dev/null
+++ b/sample/logindialog.cpp
@@ -0,0 +1,68 @@
+/*******************************************************************************
+* logindialog.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <iostream>
+#include "logindialog.h"
+#include "camerapanel.h"
+
+#include <QGridLayout>
+#include <QLabel>
+
+LoginDialog::LoginDialog(QWidget *parent)
+{
+    cameraPanel = parent;
+    setWindowTitle("Login");
+    cameraName = new QLabel("Camera Name:");
+    buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
+    username = new QLineEdit;
+    password = new QLineEdit;
+    QGridLayout *layout = new QGridLayout;
+    layout->addWidget(cameraName,             0, 0, 1, 2);
+    layout->addWidget(new QLabel("Username"), 1, 0, 1, 1);
+    layout->addWidget(username,               1, 1, 1, 1);
+    layout->addWidget(new QLabel("Password"), 2, 0, 1, 1);
+    layout->addWidget(password,               2, 1, 1, 1);
+    layout->addWidget(buttonBox,              4, 0, 1, 2);
+    setLayout(layout);
+
+    connect(buttonBox, SIGNAL(accepted()), this, SLOT(accept()));
+    connect(buttonBox, SIGNAL(rejected()), this, SLOT(reject()));
+}
+
+int LoginDialog::exec()
+{
+    QRect rect = CP->geometry();
+
+    setMinimumWidth(300);
+
+    QPoint global = CP->mapToGlobal(QPoint(rect.x(), rect.y()));
+
+    int x = global.x() + rect.width() / 2 - 150;
+    int y = global.y() + rect.height() / 2 - 150;
+
+    move(x, y);
+
+    username->setText("");
+    password->setText("");
+    username->setFocus();
+    return QDialog::exec();
+}
+
diff --git a/sample/logindialog.h b/sample/logindialog.h
new file mode 100644
index 0000000..dc275e0
--- /dev/null
+++ b/sample/logindialog.h
@@ -0,0 +1,59 @@
+/*******************************************************************************
+* logindialog.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef LOGINDIALOG_H
+#define LOGINDIALOG_H
+
+#include <QDialog>
+#include <QLineEdit>
+#include <QPushButton>
+#include <QDialogButtonBox>
+#include <QMainWindow>
+#include <QLabel>
+#include <QCheckBox>
+
+class Credential
+{
+public:
+    char camera_name[1024];
+    char username[128];
+    char password[128];
+    bool accept_requested;
+};
+
+class LoginDialog : public QDialog
+{
+    Q_OBJECT
+
+public:
+    LoginDialog(QWidget *parent);
+    int exec() override;
+
+    QWidget *cameraPanel;
+    QLabel *cameraName;
+    QDialogButtonBox *buttonBox;
+    QLineEdit *username;
+    QLineEdit *password;
+    Credential credential;
+
+};
+
+#endif // LOGINDIALOG_H
diff --git a/sample/main.cpp b/sample/main.cpp
index 115a22b..b2fad4d 100644
--- a/sample/main.cpp
+++ b/sample/main.cpp
@@ -1,3 +1,24 @@
+/*******************************************************************************
+* main.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
 #include "mainwindow.h"
 #include <QApplication>
 
diff --git a/sample/mainwindow.cpp b/sample/mainwindow.cpp
index 6ee2c7c..41c0c16 100644
--- a/sample/mainwindow.cpp
+++ b/sample/mainwindow.cpp
@@ -1,64 +1,74 @@
+/*******************************************************************************
+* mainwindow.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
 #include <iostream>
 #include "mainwindow.h"
 #include <QGridLayout>
-#include "onvif.h"
+#include <QApplication>
+#include <QScreen>
 
 MainWindow::MainWindow(QWidget *parent)
     : QMainWindow(parent)
 {
-    btnTest = new QPushButton("test");
-    connect(btnTest, SIGNAL(clicked()), this, SLOT(test()));
-    txtUsername = new QLineEdit();
-    txtUsername->setMaximumWidth(100);
-    txtPassword = new QLineEdit();
-    txtPassword->setMaximumWidth(100);
-    txtStatus = new QTextEdit();
-    txtStatus->setMinimumHeight(150);
-    txtStatus->setMinimumWidth(400);
-    QWidget* panel = new QWidget();
+    settings = new QSettings("libonvif", "onvif");
+    cameraPanel = new CameraPanel(this);
+    setMinimumWidth(600);
+
+    QWidget* layoutPanel = new QWidget();
     QGridLayout* layout = new QGridLayout();
-    layout->addWidget(new QLabel("username"), 0, 0, 1, 1);
-    layout->addWidget(txtUsername,            0, 1, 1, 1);
-    layout->addWidget(new QLabel("password"), 1, 0, 1, 1);
-    layout->addWidget(txtPassword,            1, 1, 1, 1);
-    layout->addWidget(txtStatus,              2, 0, 1, 3);
-    layout->addWidget(btnTest,                3, 1, 1, 1);
-    panel->setLayout(layout);
-    setCentralWidget(panel);
+    layout->addWidget(cameraPanel,            0, 0, 1, 1);
+    layoutPanel->setLayout(layout);
+    setCentralWidget(layoutPanel);
+
+    QRect savedGeometry = settings->value("geometry").toRect();
+    if (savedGeometry.isValid()) {
+        setGeometry(savedGeometry);
+    }
+    else {
+        QList<QScreen*> screens = QGuiApplication::screens();
+        QSize screenSize = screens[0]->size();
+        int x = (screenSize.width() - width()) / 2;
+        int y = (screenSize.height() - height()) / 2;
+        move(x, y);
+    }
 }
 
 MainWindow::~MainWindow()
 {
 }
 
-void MainWindow::test()
+void MainWindow::keyPressEvent(QKeyEvent* event)
 {
-    struct OnvifSession *onvif_session = (struct OnvifSession*)malloc(sizeof(struct OnvifSession));
-    struct OnvifData *onvif_data = (struct OnvifData*)malloc(sizeof(struct OnvifData));
-
-    initializeSession(onvif_session);
-    int number_of_cameras = broadcast(onvif_session);
-    strStatus = QString("libonvif found ") + QString::number(number_of_cameras) + QString(" cameras\r\n");
-    txtStatus->setText(strStatus);
-
-    for (int i = 0; i < number_of_cameras; i++) {
-        prepareOnvifData(i, onvif_session, onvif_data);
-
-        strcpy(onvif_data->username, txtUsername->text().toLatin1());
-        strcpy(onvif_data->password, txtPassword->text().toLatin1());
-
-        if (fillRTSP(onvif_data) == 0) {
-            strStatus += QString(onvif_data->stream_uri) + QString("\r\n");
-        }
-        else {
-            strStatus += QString("Error getting camera uri - ") + QString(onvif_data->last_error) + QString("\r\n");
-        }
-
-        txtStatus->setText(strStatus);
-
+    if (event->key() == Qt::Key_Escape) {
+        close();
     }
+}
 
-    closeSession(onvif_session);
-    free(onvif_session);
-    free(onvif_data);
+void MainWindow::closeEvent(QCloseEvent* event)
+{
+    Q_UNUSED(event);
+    settings->setValue("geometry", geometry());
+}
+
+void MainWindow::msg(QString str)
+{
+    std::cout << (const char*)str.toLatin1() << std::endl;
 }
diff --git a/sample/mainwindow.h b/sample/mainwindow.h
index 0e80b5b..2b5ae99 100644
--- a/sample/mainwindow.h
+++ b/sample/mainwindow.h
@@ -1,3 +1,24 @@
+/*******************************************************************************
+* mainwindow.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
 #ifndef MAINWINDOW_H
 #define MAINWINDOW_H
 
@@ -6,6 +27,11 @@
 #include <QLabel>
 #include <QLineEdit>
 #include <QTextEdit>
+#include <QSettings>
+#include "camerapanel.h"
+#include <iostream>
+
+#define MW dynamic_cast<MainWindow*>(mainWindow)
 
 class MainWindow : public QMainWindow
 {
@@ -15,14 +41,15 @@ public:
     MainWindow(QWidget *parent = nullptr);
     ~MainWindow();
 
-    QPushButton* btnTest;
-    QLineEdit* txtUsername;
-    QLineEdit* txtPassword;
-    QTextEdit* txtStatus;
-    QString strStatus;
+    void keyPressEvent(QKeyEvent* event) override;
+    void closeEvent(QCloseEvent* event) override;
+
+    CameraPanel* cameraPanel;
+    QSettings *settings;
+
 
 public slots:
-    void test();
+    void msg(QString);
 
 };
 #endif // MAINWINDOW_H
diff --git a/sample/networktab.cpp b/sample/networktab.cpp
new file mode 100644
index 0000000..b7ee764
--- /dev/null
+++ b/sample/networktab.cpp
@@ -0,0 +1,176 @@
+/*******************************************************************************
+* networktab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "camerapanel.h"
+
+#include <QGridLayout>
+#include <QLabel>
+#include <QThreadPool>
+
+NetworkTab::NetworkTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    checkDHCP = new QCheckBox(tr("DHCP Enabled"), this);
+    textIPAddress = new QLineEdit();
+    textIPAddress->setMaximumWidth(150);
+    textSubnetMask = new QLineEdit();
+    textSubnetMask->setMaximumWidth(150);
+    textDefaultGateway = new QLineEdit();
+    textDefaultGateway->setMaximumWidth(150);
+    textDNS = new QLineEdit();
+    textDNS->setMaximumWidth(150);
+
+    lblIPAddress = new QLabel("IP Address");
+    lblSubnetMask = new QLabel("Subnet Mask");
+    lblDefaultGateway = new QLabel("Gateway");
+    lblDNS = new QLabel("Primary DNS");
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(checkDHCP,           0, 1, 1, 1);
+    layout->addWidget(lblIPAddress,        1, 0, 1, 1);
+    layout->addWidget(textIPAddress,       1, 1, 1, 1);
+    layout->addWidget(lblSubnetMask,       2, 0, 1, 1);
+    layout->addWidget(textSubnetMask,      2, 1, 1, 1);
+    layout->addWidget(lblDefaultGateway,   3, 0, 1, 1);
+    layout->addWidget(textDefaultGateway,  3, 1, 1, 1);
+    layout->addWidget(lblDNS,              4, 0, 1, 1);
+    layout->addWidget(textDNS,             4, 1, 1, 1);
+    setLayout(layout);
+
+    connect(checkDHCP, SIGNAL(clicked()), this, SLOT(dhcpChecked()));
+    connect(textIPAddress, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString &)));
+    connect(textDefaultGateway, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString &)));
+    connect(textDNS, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString &)));
+    connect(textSubnetMask, SIGNAL(textChanged(const QString &)), this, SLOT(onTextChanged(const QString &)));
+
+    updater = new NetworkUpdater(cameraPanel);
+    connect(updater, SIGNAL(done()), this, SLOT(doneUpdating()));
+}
+
+void NetworkTab::update()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    onvif_data->dhcp_enabled = checkDHCP->isChecked();
+    QString ip_address = textIPAddress->text();
+    strncpy(onvif_data->ip_address_buf, ip_address.toLatin1(), ip_address.length());
+    onvif_data->ip_address_buf[ip_address.length()] = '\0';
+    QString default_gateway = textDefaultGateway->text();
+    strncpy(onvif_data->default_gateway_buf, default_gateway.toLatin1(), default_gateway.length());
+    onvif_data->default_gateway_buf[default_gateway.length()] = '\0';
+    QString dns = textDNS->text();
+    strncpy(onvif_data->dns_buf, dns.toLatin1(), dns.length());
+    onvif_data->dns_buf[dns.length()] = '\0';
+    onvif_data->prefix_length = mask2prefix(textSubnetMask->text().toLatin1().data());
+
+    QThreadPool::globalInstance()->tryStart(updater);
+}
+
+void NetworkTab::clear()
+{
+    checkDHCP->setChecked(false);
+    textIPAddress->setText("");
+    textSubnetMask->setText("");
+    textDefaultGateway->setText("");
+    textDNS->setText("");
+}
+
+void NetworkTab::setActive(bool active)
+{
+    checkDHCP->setEnabled(active);
+    textIPAddress->setEnabled(active);
+    textSubnetMask->setEnabled(active);
+    textDefaultGateway->setEnabled(active);
+    textDNS->setEnabled(active);
+    lblIPAddress->setEnabled(active);
+    lblSubnetMask->setEnabled(active);
+    lblDefaultGateway->setEnabled(active);
+    lblDNS->setEnabled(active);
+}
+
+bool NetworkTab::hasBeenEdited()
+{
+    bool result = false;
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+
+    if (strcmp(textIPAddress->text().toLatin1().data(), "") != 0) {
+        if (checkDHCP->isChecked() != onvif_data->dhcp_enabled)
+            result = true;
+        if (strcmp(textIPAddress->text().toLatin1().data(), onvif_data->ip_address_buf) != 0)
+            result = true;
+        if (mask2prefix(textSubnetMask->text().toLatin1().data()) != onvif_data->prefix_length)
+            result = true;
+        if (strcmp(textDefaultGateway->text().toLatin1().data(), onvif_data->default_gateway_buf) != 0)
+            result = true;
+        if (strcmp(textDNS->text().toLatin1().data(), onvif_data->dns_buf) != 0)
+            result = true;
+    }
+
+    return result;
+}
+
+void NetworkTab::initialize()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    textIPAddress->setText(tr(onvif_data->ip_address_buf));
+    char mask_buf[128] = {0};
+    prefix2mask(onvif_data->prefix_length, mask_buf);
+    textSubnetMask->setText(tr(mask_buf));
+    textDNS->setText(tr(onvif_data->dns_buf));
+    textDefaultGateway->setText(tr(onvif_data->default_gateway_buf));
+    setDHCP(onvif_data->dhcp_enabled);
+}
+
+void NetworkTab::setDHCP(bool used)
+{
+    checkDHCP->setChecked(used);
+    textIPAddress->setEnabled(!used);
+    textSubnetMask->setEnabled(!used);
+    textDefaultGateway->setEnabled(!used);
+    textDNS->setEnabled(!used);
+}
+
+void NetworkTab::dhcpChecked()
+{
+    bool used = checkDHCP->isChecked();
+    textIPAddress->setEnabled(!used);
+    textSubnetMask->setEnabled(!used);
+    textDefaultGateway->setEnabled(!used);
+    textDNS->setEnabled(!used);
+    if (hasBeenEdited())
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(true);
+    else
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(false);
+}
+
+void NetworkTab::onTextChanged(const QString &)
+{
+    if (hasBeenEdited())
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(true);
+    else
+        ((CameraPanel *)cameraPanel)->applyButton->setEnabled(false);
+}
+
+void NetworkTab::doneUpdating()
+{
+    fprintf(stderr, "done updating\n");
+    ((CameraPanel *)cameraPanel)->applyButton->setEnabled(false);
+}
diff --git a/sample/networktab.h b/sample/networktab.h
new file mode 100644
index 0000000..946b521
--- /dev/null
+++ b/sample/networktab.h
@@ -0,0 +1,67 @@
+/*******************************************************************************
+* networktab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef NETWORKTAB_H
+#define NETWORKTAB_H
+
+#include "cameradialogtab.h"
+#include "onvifmanager.h"
+
+#include <QCheckBox>
+#include <QLineEdit>
+#include <QLabel>
+
+class NetworkTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    NetworkTab(QWidget *parent);
+
+    QCheckBox *checkDHCP;
+    QLineEdit *textIPAddress;
+    QLineEdit *textSubnetMask;
+    QLineEdit *textDefaultGateway;
+    QLineEdit *textDNS;
+
+    QLabel *lblIPAddress;
+    QLabel *lblSubnetMask;
+    QLabel *lblDefaultGateway;
+    QLabel *lblDNS;
+
+    QWidget *cameraPanel;
+
+    NetworkUpdater *updater;
+
+    void update() override;
+    void clear() override;
+    void setActive(bool active) override;
+    bool hasBeenEdited() override;
+    void initialize();
+    void setDHCP(bool used);
+
+private slots:
+    void dhcpChecked();
+    void onTextChanged(const QString &);
+    void doneUpdating();
+};
+
+#endif // NETWORKTAB_H
diff --git a/sample/onvifmanager.cpp b/sample/onvifmanager.cpp
new file mode 100644
index 0000000..92e8c47
--- /dev/null
+++ b/sample/onvifmanager.cpp
@@ -0,0 +1,202 @@
+/*******************************************************************************
+* onvifmanager.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include <iostream>
+#include "onvifmanager.h"
+#include "camerapanel.h"
+
+Filler::Filler(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void Filler::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    getCapabilities(onvif_data);
+    getNetworkInterfaces(onvif_data);
+    getNetworkDefaultGateway(onvif_data);
+    getDNS(onvif_data);
+    getVideoEncoderConfigurationOptions(onvif_data);
+    getVideoEncoderConfiguration(onvif_data);
+    getOptions(onvif_data);
+    getImagingSettings(onvif_data);
+
+    emit done();
+}
+
+VideoUpdater::VideoUpdater(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void VideoUpdater::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    setVideoEncoderConfiguration(onvif_data);
+    getProfile(onvif_data);
+    getVideoEncoderConfigurationOptions(onvif_data);
+    getVideoEncoderConfiguration(onvif_data);
+    emit done();
+}
+
+ImageUpdater::ImageUpdater(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void ImageUpdater::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    setImagingSettings(onvif_data);
+    getOptions(onvif_data);
+    getImagingSettings(onvif_data);
+    emit done();
+}
+
+NetworkUpdater::NetworkUpdater(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void NetworkUpdater::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    setNetworkInterfaces(onvif_data);
+    setDNS(onvif_data);
+    setNetworkDefaultGateway(onvif_data);
+    emit done();
+}
+
+Rebooter::Rebooter(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void Rebooter::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    rebootCamera(onvif_data);
+    emit done();
+}
+
+Resetter::Resetter(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void Resetter::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    hardReset(onvif_data);
+    emit done();
+}
+
+Timesetter::Timesetter(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void Timesetter::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    setSystemDateAndTime(onvif_data);
+    emit done();
+}
+
+PTZMover::PTZMover(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void PTZMover::set(float x_arg, float y_arg, float z_arg)
+{
+    x = x_arg; y = y_arg; z = z_arg;
+}
+
+void PTZMover::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    continuousMove(x, y, z, onvif_data);
+}
+
+PTZStopper::PTZStopper(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void PTZStopper::set(int type_arg)
+{
+    type = type_arg;
+}
+
+void PTZStopper::run()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    moveStop(type, onvif_data);
+}
+
+PTZGoto::PTZGoto(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void PTZGoto::set(int position_arg)
+{
+    position = position_arg;
+}
+
+void PTZGoto::run()
+{
+    char pos[128] = {0};
+    sprintf(pos, "%d", position);
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    gotoPreset(pos, onvif_data);
+}
+
+PTZSetPreset::PTZSetPreset(QWidget *parent)
+{
+    cameraPanel = parent;
+    setAutoDelete(false);
+}
+
+void PTZSetPreset::set(int position_arg)
+{
+    position = position_arg;
+}
+
+void PTZSetPreset::run()
+{
+    char pos[128] = {0};
+    sprintf(pos, "%d", position);
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    setPreset(pos, onvif_data);
+}
diff --git a/sample/onvifmanager.h b/sample/onvifmanager.h
new file mode 100644
index 0000000..bed03cc
--- /dev/null
+++ b/sample/onvifmanager.h
@@ -0,0 +1,203 @@
+/*******************************************************************************
+* onvifmanager.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef ONVIFMANAGER_H
+#define ONVIFMANAGER_H
+
+#include <QObject>
+#include <QRunnable>
+#include <QMutex>
+
+#define ZOOM_FACTOR 16
+
+class Filler : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    Filler(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class VideoUpdater : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    VideoUpdater(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class ImageUpdater : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    ImageUpdater(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class NetworkUpdater : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    NetworkUpdater(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class Rebooter : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    Rebooter(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class Resetter : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    Resetter(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class Timesetter : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    Timesetter(QWidget *parent);
+    void run() override;
+
+private:
+    QWidget *cameraPanel;
+
+signals:
+    void done();
+
+};
+
+class PTZMover : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    PTZMover(QWidget *parent);
+    void run() override;
+    void set(float x_arg, float y_arg, float z_arg);
+
+private:
+    QWidget *cameraPanel;
+    float x; float y; float z;
+
+};
+
+class PTZStopper : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    PTZStopper(QWidget *parent);
+    void run() override;
+    void set(int type_arg);
+
+private:
+    QWidget *cameraPanel;
+    int type;
+
+};
+
+class PTZGoto : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    PTZGoto(QWidget *parent);
+    void run() override;
+    void set(int position_arg);
+
+private:
+    QWidget *cameraPanel;
+    int position;
+
+};
+
+class PTZSetPreset : public QObject, public QRunnable
+{
+    Q_OBJECT
+
+public:
+    PTZSetPreset(QWidget *parent);
+    void run() override;
+    void set(int position_arg);
+
+private:
+    QWidget *cameraPanel;
+    int position;
+
+};
+
+#endif // ONVIFMANAGER_H
diff --git a/sample/ptztab.cpp b/sample/ptztab.cpp
new file mode 100644
index 0000000..e43ee13
--- /dev/null
+++ b/sample/ptztab.cpp
@@ -0,0 +1,198 @@
+/*******************************************************************************
+* ptztab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+//#include "camerapanel.h"
+//#include "mainwindow.h"
+#include "onvif.h"
+#include "ptztab.h"
+#include <QGridLayout>
+#include <QThreadPool>
+
+PTZTab::PTZTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    const int BUTTON_SIZE = 30;
+    for (int i = 0; i < 10; i++)
+        speed[i] = 0.09 * (i+1);
+
+    labelSpeed = new QLabel("PTZ speed");
+    labelSpeed->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
+
+    comboSpeed = new QComboBox();
+    comboSpeed->addItem(tr("1"));
+    comboSpeed->addItem(tr("2"));
+    comboSpeed->addItem(tr("3"));
+    comboSpeed->addItem(tr("4"));
+    comboSpeed->addItem(tr("5"));
+    comboSpeed->addItem(tr("6"));
+    comboSpeed->addItem(tr("7"));
+    comboSpeed->addItem(tr("8"));
+    comboSpeed->addItem(tr("9"));
+    comboSpeed->addItem(tr("10"));
+    comboSpeed->setMaximumWidth(40);
+    comboSpeed->setCurrentIndex(4);
+
+    textPreset = new QLineEdit;
+    textPreset->setMaximumWidth(35);
+    buttonPreset = new QPushButton(tr("Go"), this);
+    buttonPreset->setMaximumWidth(35);
+    connect(buttonPreset, SIGNAL(clicked()), this, SLOT(userPreset()));
+
+    button1 = new QPushButton(tr("1"), this);
+    button2 = new QPushButton(tr("2"), this);
+    button3 = new QPushButton(tr("3"), this);
+    button4 = new QPushButton(tr("4"), this);
+    button5 = new QPushButton(tr("5"), this);
+    button1->setMaximumWidth(BUTTON_SIZE);
+    button2->setMaximumWidth(BUTTON_SIZE);
+    button3->setMaximumWidth(BUTTON_SIZE);
+    button4->setMaximumWidth(BUTTON_SIZE);
+    button5->setMaximumWidth(BUTTON_SIZE);
+
+    connect(button1, &QPushButton::clicked, [=] {preset(0);});
+    connect(button2, &QPushButton::clicked, [=] {preset(1);});
+    connect(button3, &QPushButton::clicked, [=] {preset(2);});
+    connect(button4, &QPushButton::clicked, [=] {preset(3);});
+    connect(button5, &QPushButton::clicked, [=] {preset(4);});
+
+    checkPreset = new QCheckBox(tr("Set Preset"), this);
+
+    buttonUp = new QPushButton(tr("^"), this);
+    buttonDown = new QPushButton(tr("v"), this);
+    buttonLeft = new QPushButton(tr("<"), this);
+    buttonRight = new QPushButton(tr(">"), this);
+    buttonZoomIn = new QPushButton(tr("Zoom In"), this);
+    buttonZoomOut = new QPushButton(tr("Zoom Out"), this);
+    buttonUp->setMaximumWidth(45);
+    buttonDown->setMaximumWidth(45);
+    buttonLeft->setMaximumWidth(45);
+    buttonRight->setMaximumWidth(45);
+    buttonZoomIn->setMaximumWidth(90);
+    buttonZoomOut->setMaximumWidth(90);
+
+    connect(buttonUp, &QPushButton::pressed, [=] {move(0.0, speed[comboSpeed->currentIndex()], 0.0);});
+    connect(buttonDown, &QPushButton::pressed, [=] {move(0.0, speed[comboSpeed->currentIndex()] * -1, 0.0);});
+    connect(buttonLeft, &QPushButton::pressed, [=] {move(speed[comboSpeed->currentIndex()] * -1, 0.0, 0.0);});
+    connect(buttonRight, &QPushButton::pressed, [=] {move(speed[comboSpeed->currentIndex()], 0.0, 0.0);});
+    connect(buttonZoomIn, &QPushButton::pressed, [=] {move(0.0, 0.0, speed[comboSpeed->currentIndex()]);});
+    connect(buttonZoomOut, &QPushButton::pressed, [=] {move(0.0, 0.0, speed[comboSpeed->currentIndex()] * -1);});
+    connect(buttonUp, SIGNAL(released()), this, SLOT(stopPanTilt()));
+    connect(buttonDown, SIGNAL(released()), this, SLOT(stopPanTilt()));
+    connect(buttonLeft, SIGNAL(released()), this, SLOT(stopPanTilt()));
+    connect(buttonRight, SIGNAL(released()), this, SLOT(stopPanTilt()));
+    connect(buttonZoomIn, SIGNAL(released()), this, SLOT(stopZoom()));
+    connect(buttonZoomOut, SIGNAL(released()), this, SLOT(stopZoom()));
+
+    QGridLayout *layout = new QGridLayout( this );
+    layout->addWidget(textPreset,    1, 2, 1, 3);
+    layout->addWidget(buttonPreset,  1, 3, 1, 1);
+    layout->addWidget(checkPreset,   1, 4, 1, 2);
+    layout->addWidget(button1,       1, 1, 1, 1);
+    layout->addWidget(button2,       2, 1, 1, 1);
+    layout->addWidget(button3,       3, 1, 1, 1);
+    layout->addWidget(button4,       4, 1, 1, 1);
+    layout->addWidget(button5,       5, 1, 1, 1);
+    layout->addWidget(buttonLeft,    3, 2, 1, 1);
+    layout->addWidget(buttonUp,      2, 3, 1, 1);
+    layout->addWidget(buttonRight,   3, 4, 1, 1);
+    layout->addWidget(buttonDown,    4, 3, 1, 1);
+    layout->addWidget(buttonZoomIn,  2, 5, 1, 1);
+    layout->addWidget(buttonZoomOut, 3, 5, 1, 1);
+    layout->addWidget(labelSpeed,    5, 2, 1, 2);
+    layout->addWidget(comboSpeed,    5, 4, 1, 2);
+
+    ptzMover = new PTZMover(cameraPanel);
+    ptzStopper = new PTZStopper(cameraPanel);
+    ptzGoto = new PTZGoto(cameraPanel);
+    ptzSetPreset = new PTZSetPreset(cameraPanel);
+}
+
+void PTZTab::update()
+{
+
+}
+
+void PTZTab::setActive(bool active)
+{
+    checkPreset->setEnabled(active);
+    textPreset->setEnabled(active);
+    labelSpeed->setEnabled(active);
+    comboSpeed->setEnabled(active);
+    button1->setEnabled(active);
+    button2->setEnabled(active);
+    button3->setEnabled(active);
+    button4->setEnabled(active);
+    button5->setEnabled(active);
+    buttonUp->setEnabled(active);
+    buttonDown->setEnabled(active);
+    buttonLeft->setEnabled(active);
+    buttonRight->setEnabled(active);
+    buttonZoomIn->setEnabled(active);
+    buttonZoomOut->setEnabled(active);
+    buttonPreset->setEnabled(active);
+}
+
+bool PTZTab::hasBeenEdited()
+{
+    return false;
+}
+
+void PTZTab::preset(int arg)
+{
+    if (checkPreset->isChecked()) {
+        ptzSetPreset->set(arg);
+        QThreadPool::globalInstance()->tryStart(ptzSetPreset);
+        checkPreset->setChecked(false);
+    }
+    else {
+        ptzGoto->set(arg);
+        QThreadPool::globalInstance()->tryStart(ptzGoto);
+    }
+}
+
+void PTZTab::userPreset()
+{
+    bool ok;
+    int arg = textPreset->text().toInt(&ok);
+    if (ok) {
+        preset(arg);
+    }
+}
+
+void PTZTab::move(float x, float y, float z)
+{
+    ptzMover->set(x, y, z);
+    QThreadPool::globalInstance()->tryStart(ptzMover);
+}
+
+void PTZTab::stopPanTilt()
+{
+    ptzStopper->set(PAN_TILT_STOP);
+    QThreadPool::globalInstance()->tryStart(ptzStopper);
+}
+
+void PTZTab::stopZoom()
+{
+    ptzStopper->set(ZOOM_STOP);
+    QThreadPool::globalInstance()->tryStart(ptzStopper);
+}
+
diff --git a/sample/ptztab.h b/sample/ptztab.h
new file mode 100644
index 0000000..871087c
--- /dev/null
+++ b/sample/ptztab.h
@@ -0,0 +1,83 @@
+/*******************************************************************************
+* ptztab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef PTZTAB_H
+#define PTZTAB_H
+
+#include "cameradialogtab.h"
+#include "onvifmanager.h"
+
+#include <QCheckBox>
+#include <QTextEdit>
+#include <QLineEdit>
+#include <QComboBox>
+#include <QPushButton>
+#include <QLabel>
+
+class PTZTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    PTZTab(QWidget *parent);
+
+    QCheckBox *checkPreset;
+    QCheckBox *checkDigitalPTZ;
+    QLineEdit *textPreset;
+    QComboBox *comboSpeed;
+    QPushButton *button1;
+    QPushButton *button2;
+    QPushButton *button3;
+    QPushButton *button4;
+    QPushButton *button5;
+    QPushButton *buttonUp;
+    QPushButton *buttonDown;
+    QPushButton *buttonLeft;
+    QPushButton *buttonRight;
+    QPushButton *buttonZoomIn;
+    QPushButton *buttonZoomOut;
+    QPushButton *buttonPreset;
+    QLabel *labelZoom;
+    QLabel *labelSpeed;
+
+    float speed[10];
+
+    QWidget *cameraPanel;
+
+    PTZMover *ptzMover;
+    PTZStopper *ptzStopper;
+    PTZGoto *ptzGoto;
+    PTZSetPreset *ptzSetPreset;
+
+    void update() override;
+    void setActive(bool active) override;
+    bool hasBeenEdited() override;
+
+private slots:
+    void preset(int);
+    void userPreset();
+    void move(float, float, float);
+    void stopPanTilt();
+    void stopZoom();
+
+};
+
+#endif // PTZTAB_H
diff --git a/sample/sample.pro b/sample/sample.pro
index 10152e4..8fa2f8d 100644
--- a/sample/sample.pro
+++ b/sample/sample.pro
@@ -5,11 +5,39 @@ greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
 CONFIG += c++17
 
 SOURCES += \
+    admintab.cpp \
+    camera.cpp \
+    cameradialogtab.cpp \
+    cameralistmodel.cpp \
+    cameralistview.cpp \
+    camerapanel.cpp \
+    configtab.cpp \
+    discovery.cpp \
+    imagetab.cpp \
+    logindialog.cpp \
     main.cpp \
-    mainwindow.cpp
+    mainwindow.cpp \
+    networktab.cpp \
+    onvifmanager.cpp \
+    ptztab.cpp \
+    videotab.cpp
 
 HEADERS += \
-    mainwindow.h
+    admintab.h \
+    camera.h \
+    cameradialogtab.h \
+    cameralistmodel.h \
+    cameralistview.h \
+    camerapanel.h \
+    configtab.h \
+    discovery.h \
+    imagetab.h \
+    logindialog.h \
+    mainwindow.h \
+    networktab.h \
+    onvifmanager.h \
+    ptztab.h \
+    videotab.h
 
 unix: LIBS += -L/usr/local/lib/ -lonvif -lxml2
 
@@ -17,7 +45,11 @@ win32: LIBS += -L'C:/Program Files (x86)/libonvif/lib/' -lonvif \
                -L'C:/Program Files (x86)/libxml2/lib/' -llibxml2
 
 unix: INCLUDEPATH += /usr/local/include \
-                          /usr/include/libxml2
+                     /usr/include/libxml2 \
 
 win32: INCLUDEPATH += 'C:/Program Files (x86)/libonvif/include' \
                       'C:/Program Files (x86)/libxml2/include/libxml2'
+
+DISTFILES += \
+    CMakeLists.txt \
+    sample.pro.user
diff --git a/sample/videotab.cpp b/sample/videotab.cpp
new file mode 100644
index 0000000..82a9584
--- /dev/null
+++ b/sample/videotab.cpp
@@ -0,0 +1,195 @@
+/*******************************************************************************
+* videotab.cpp
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#include "camerapanel.h"
+
+#include <QLabel>
+#include <QGridLayout>
+#include <QThreadPool>
+
+SpinBox::SpinBox(QLineEdit *editor)
+{
+    setLineEdit(editor);
+}
+
+VideoTab::VideoTab(QWidget *parent)
+{
+    cameraPanel = parent;
+
+    comboResolutions = new QComboBox();
+
+    QLineEdit *textBitrate = new QLineEdit();
+    spinBitrate = new SpinBox(textBitrate);
+
+    QLineEdit *textFrameRate = new QLineEdit();
+    spinFrameRate = new SpinBox(textFrameRate);
+
+    QLineEdit *textGovLength = new QLineEdit();
+    spinGovLength = new SpinBox(textGovLength);
+
+    lblResolutions = new QLabel("Resolution");
+    lblFrameRate = new QLabel("Frame Rate");
+    lblGovLength = new QLabel("Gov Length");
+    lblBitrate = new QLabel("Bitrate");
+
+    QGridLayout *layout = new QGridLayout();
+    layout->addWidget(lblResolutions,    0, 0, 1, 1);
+    layout->addWidget(comboResolutions,  0, 1, 1, 1);
+    layout->addWidget(lblFrameRate,      1, 0, 1, 1);
+    layout->addWidget(spinFrameRate,     1, 1, 1, 1);
+    layout->addWidget(lblGovLength,      2, 0, 1, 1);
+    layout->addWidget(spinGovLength,     2, 1, 1, 1);
+    layout->addWidget(lblBitrate,        3, 0, 1, 1);
+    layout->addWidget(spinBitrate,       3, 1, 1, 1);
+    setLayout(layout);
+
+    connect(comboResolutions, SIGNAL(currentIndexChanged(int)), this, SLOT(onCurrentIndexChanged(int)));
+    connect(spinFrameRate, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+    connect(spinGovLength, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+    connect(spinBitrate, SIGNAL(valueChanged(int)), this, SLOT(onValueChanged(int)));
+
+    updater = new VideoUpdater(cameraPanel);
+    connect(updater, SIGNAL(done()), this, SLOT(initialize()));
+}
+
+void VideoTab::update()
+{
+    OnvifData *onvif_data = ((CameraPanel *)cameraPanel)->camera->onvif_data;
+    onvif_data->frame_rate = spinFrameRate->value();
+    onvif_data->gov_length = spinGovLength->value();
+    onvif_data->bitrate = spinBitrate->value();
+    char * resolution_buf = comboResolutions->currentText().toLatin1().data();
+    char * mark = strstr(resolution_buf, "x");
+    int length = strlen(resolution_buf);
+    int point = mark - resolution_buf;
+    char width_buf[128] = {0};
+    char height_buf[128] = {0};
+    for (int i=0; i<point-1; i++)
+        width_buf[i] = resolution_buf[i];
+    for (int i=point+2; i<length; i++)
+        height_buf[i-(point+2)] = resolution_buf[i];
+    onvif_data->width = atoi(width_buf);
+    onvif_data->height = atoi(height_buf);
+
+    QThreadPool::globalInstance()->tryStart(updater);
+}
+
+void VideoTab::clear()
+{
+    comboResolutions->clear();
+    spinFrameRate->setValue(0);
+    spinGovLength->setValue(0);
+    spinBitrate->setValue(0);
+    spinGovLength->setMinimum(0);
+    spinGovLength->setMaximum(0);
+    spinFrameRate->setMinimum(0);
+    spinFrameRate->setMaximum(0);
+    spinBitrate->setMinimum(0);
+    spinBitrate->setMaximum(0);
+}
+
+void VideoTab::setActive(bool active)
+{
+    comboResolutions->setEnabled(active);
+    spinFrameRate->setEnabled(active);
+    spinGovLength->setEnabled(active);
+    spinBitrate->setEnabled(active);
+    lblResolutions->setEnabled(active);
+    lblFrameRate->setEnabled(active);
+    lblGovLength->setEnabled(active);
+    lblBitrate->setEnabled(active);
+}
+
+void VideoTab::initialize()
+{
+    OnvifData *onvif_data = CP->camera->onvif_data;
+
+    comboResolutions->clear();
+
+    int size = 0;
+    bool found_size = false;
+    while (!found_size) {
+        if (strlen(onvif_data->resolutions_buf[size]) == 0) {
+            found_size = true;
+        }
+        else {
+            size++;
+            if (size > 15)
+                found_size = true;
+        }
+    }
+
+    for (int i=0; i<size; i++) {
+        comboResolutions->addItem(tr(onvif_data->resolutions_buf[i]));
+    }
+
+    spinGovLength->setMinimum(onvif_data->gov_length_min);
+    spinGovLength->setMaximum(onvif_data->gov_length_max);
+    spinFrameRate->setMinimum(onvif_data->frame_rate_min);
+    spinFrameRate->setMaximum(onvif_data->frame_rate_max);
+    spinBitrate->setMinimum(onvif_data->bitrate_min);
+    spinBitrate->setMaximum(onvif_data->bitrate_max);
+
+    char res[128] = {0};
+    sprintf(res, "%d x %d", onvif_data->width, onvif_data->height);
+    comboResolutions->setCurrentText(tr(res));
+    spinGovLength->setValue(onvif_data->gov_length);
+    spinFrameRate->setValue(onvif_data->frame_rate);
+    spinBitrate->setValue(onvif_data->bitrate);
+    CP->applyButton->setEnabled(false);
+
+}
+
+bool VideoTab::hasBeenEdited() {
+    OnvifData *onvif_data = CP->camera->onvif_data;
+    bool result = false;
+    if (strcmp(comboResolutions->currentText().toLatin1().data(), "") != 0) {
+        if (spinGovLength->value() != onvif_data->gov_length)
+            result = true;
+        if (spinBitrate->value() != onvif_data->bitrate)
+            result = true;
+        if (spinFrameRate->value() != onvif_data->frame_rate)
+            result = true;
+
+        char resolution[128] = {0};
+        sprintf(resolution, "%d x %d", onvif_data->width, onvif_data->height);
+        if (strcmp(comboResolutions->currentText().toLatin1().data(), resolution) != 0)
+            result = true;
+    }
+    return result;
+}
+
+void VideoTab::onCurrentIndexChanged(int index) {
+    Q_UNUSED(index);
+    if (hasBeenEdited())
+        CP->applyButton->setEnabled(true);
+    else
+        CP->applyButton->setEnabled(false);
+}
+
+void VideoTab::onValueChanged(int index) {
+    Q_UNUSED(index);
+    if (hasBeenEdited())
+        CP->applyButton->setEnabled(true);
+    else
+        CP->applyButton->setEnabled(false);
+}
+
diff --git a/sample/videotab.h b/sample/videotab.h
new file mode 100644
index 0000000..c627ebc
--- /dev/null
+++ b/sample/videotab.h
@@ -0,0 +1,72 @@
+/*******************************************************************************
+* videotab.h
+*
+* Copyright (c) 2020 Stephen Rhodes
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*
+*******************************************************************************/
+
+#ifndef VIDEOTAB_H
+#define VIDEOTAB_H
+
+#include "cameradialogtab.h"
+#include "onvifmanager.h"
+
+#include <QComboBox>
+#include <QSpinBox>
+#include <QLabel>
+
+class SpinBox : public QSpinBox
+{
+
+public:
+    SpinBox(QLineEdit *editor);
+
+};
+
+class VideoTab : public CameraDialogTab
+{
+    Q_OBJECT
+
+public:
+    VideoTab(QWidget *parent);
+    void update() override;
+    void clear() override;
+    void setActive(bool active) override;
+    bool hasBeenEdited() override;
+
+    QWidget *cameraPanel;
+    QComboBox *comboResolutions;
+    SpinBox *spinFrameRate;
+    SpinBox *spinGovLength;
+    SpinBox *spinBitrate;
+    QLabel *lblResolutions;
+    QLabel *lblFrameRate;
+    QLabel *lblGovLength;
+    QLabel *lblBitrate;
+
+    VideoUpdater *updater;
+    bool updating = false;
+
+public slots:
+    void initialize();
+
+private slots:
+    void onCurrentIndexChanged(int index);
+    void onValueChanged(int value);
+};
+
+#endif // VIDEOTAB_H
diff --git a/src/onvif.c b/src/onvif.c
old mode 100755
new mode 100644
index 6bf0078..e932940
--- a/src/onvif.c
+++ b/src/onvif.c
@@ -44,8 +44,10 @@
 #include "cencode.h"
 #include <stdint.h>
 
-#pragma comment(lib, "iphlpapi.lib")
-#pragma comment(lib, "ws2_32.lib")
+#ifdef _WIN32
+	#pragma comment(lib, "iphlpapi.lib")
+	#pragma comment(lib, "ws2_32.lib")
+#endif
 
 #define INT_TO_ADDR(_addr) \
 (_addr & 0xFF), \
@@ -55,6 +57,9 @@
 
 const int SHA1_DIGEST_SIZE = 20;
 
+static bool dump_reply = false;
+static void dumpReply(xmlDocPtr reply);
+
 int getNetworkInterfaces(struct OnvifData *onvif_data) {
     int result = 0;
     xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
@@ -97,8 +102,7 @@ int getNetworkInterfaces(struct OnvifData *onvif_data) {
                 if (dhcp) {
                     xpath_address = BAD_CAST "//tds:NetworkInterfaces//tt:IPv4//tt:Config//tt:FromDHCP//tt:Address";
                     xpath_prefix = BAD_CAST "//tds:NetworkInterfaces//tt:IPv4//tt:Config//tt:FromDHCP//tt:PrefixLength";
-                }
-                else {
+                } else {
                     xpath_address = BAD_CAST "//tds:NetworkInterfaces//tt:IPv4//tt:Config//tt:Manual//tt:Address";
                     xpath_prefix = BAD_CAST "//tds:NetworkInterfaces//tt:IPv4//tt:Config//tt:Manual//tt:PrefixLength";
                 }
@@ -130,8 +134,7 @@ int getNetworkInterfaces(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -155,8 +158,7 @@ int setNetworkInterfaces(struct OnvifData *onvif_data) {
     xmlNodePtr ipv4 = xmlNewTextChild(networkInterface, ns_tt, BAD_CAST "IPv4", NULL);
     if (onvif_data->dhcp_enabled) {
         xmlNewTextChild(ipv4, ns_tt, BAD_CAST "DHCP", BAD_CAST "true");
-    }
-    else {
+    } else {
         xmlNewTextChild(ipv4, ns_tt, BAD_CAST "DHCP", BAD_CAST "false");
         xmlNodePtr manual = xmlNewTextChild(ipv4, ns_tt, BAD_CAST "Manual", NULL);
         xmlNewTextChild(manual, ns_tt, BAD_CAST "Address" , BAD_CAST onvif_data->ip_address_buf);
@@ -178,8 +180,7 @@ int setNetworkInterfaces(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -205,8 +206,7 @@ int getNetworkDefaultGateway(struct OnvifData *onvif_data) {
         getXmlValue(reply, xpath, onvif_data->default_gateway_buf, 128);
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -232,8 +232,7 @@ int setNetworkDefaultGateway(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -261,16 +260,14 @@ int getDNS(struct OnvifData *onvif_data) {
             if (strcmp(fromDHCP, "true") == 0) {
                 xpath = BAD_CAST "//s:Body//tds:GetDNSResponse//tds:DNSInformation//tt:DNSFromDHCP//tt:IPv4Address";
                 if (getXmlValue(reply, xpath, onvif_data->dns_buf, 128) == 0) {}
-            }
-            else {
+            } else {
                 xpath = BAD_CAST "//s:Body//tds:GetDNSResponse//tds:DNSInformation//tt:DNSManual//tt:IPv4Address";
                 if (getXmlValue(reply, xpath, onvif_data->dns_buf, 128) == 0) {}
             }
         }
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -283,8 +280,7 @@ int setDNS(struct OnvifData *onvif_data) {
     char fromDHCP_buf[128];
     if (onvif_data->dhcp_enabled) {
         strcpy(fromDHCP_buf, "true");
-    }
-    else {
+    } else {
         strcpy(fromDHCP_buf, "false");
     }
 
@@ -302,8 +298,7 @@ int setDNS(struct OnvifData *onvif_data) {
         xmlNodePtr dnsManual = xmlNewTextChild(setDNS, ns_tds, BAD_CAST "DNSManual", NULL);
         xmlNewTextChild(dnsManual, ns_tt, BAD_CAST "Type", BAD_CAST "IPv4");
         xmlNewTextChild(dnsManual, ns_tt, BAD_CAST "IPv4Address", BAD_CAST onvif_data->dns_buf);
-    }
-    else {
+    } else {
         xmlNewTextChild(setDNS, ns_tds, BAD_CAST "FromDHCP", BAD_CAST fromDHCP_buf);
     }
     char cmd[4096] = {0};
@@ -312,14 +307,167 @@ int setDNS(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
+    } else {
+        result = -1;
+        strcpy(onvif_data->last_error, "No XML reply");
     }
-    else {
+    return result;
+}
+
+int getNTP(struct OnvifData *onvif_data) {
+    int result = 0;
+    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
+    xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+    xmlDocSetRootElement(doc, root);
+    xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+    xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+    xmlSetNs(root, ns_env);
+    addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+    xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+    xmlNewTextChild(body, ns_tds, BAD_CAST "GetNTP", NULL);
+    char cmd[4096] = {0};
+    addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+    xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+    if (reply != NULL) {
+		xmlChar *xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:FromDHCP";
+		char ntp_buf[128];
+		getXmlValue(reply, xpath, ntp_buf, 128);
+		if (strcmp(ntp_buf,"true") == 0) {
+			onvif_data->ntp_dhcp = true;
+			xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPFromDHCP//tt:Type";
+			getXmlValue(reply, xpath, onvif_data->ntp_type, 128);
+			if (strcmp(onvif_data->ntp_type,"IPv4") == 0)
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPFromDHCP//tt:IPv4Address";
+			else if (strcmp(onvif_data->ntp_type,"IPv4") == 0)
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPFromDHCP//tt:IPv6Address";
+			else
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPFromDHCP//tt:DNSName";
+			getXmlValue(reply, xpath, onvif_data->ntp_addr, 128);
+		} else {
+			onvif_data->ntp_dhcp = false;
+			xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPManual//tt:Type";
+			getXmlValue(reply, xpath, onvif_data->ntp_type, 128);
+			if (strcmp(onvif_data->ntp_type,"IPv4") == 0)
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPManual//tt:IPv4Address";
+			else if (strcmp(onvif_data->ntp_type,"IPv4") == 0)
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPManual//tt:IPv6Address";
+			else
+				xpath = BAD_CAST "//s:Body//tds:GetNTPResponse//tt:NTPManual//tt:DNSName";
+			getXmlValue(reply, xpath, onvif_data->ntp_addr, 128);
+		}
+    } else {
+        result = -1;
+        strcpy(onvif_data->last_error, "No XML reply");
+    }
+    return result;
+}
+
+int setNTP(struct OnvifData *onvif_data) {
+    int result = 0;
+
+    char fromDHCP_buf[128];
+    if (onvif_data->ntp_dhcp) {
+        strcpy(fromDHCP_buf, "true");
+    } else {
+        strcpy(fromDHCP_buf, "false");
+    }
+    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
+    xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+    xmlDocSetRootElement(doc, root);
+    xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+    xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+    xmlNsPtr ns_tt = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/schema", BAD_CAST "tt");
+    xmlSetNs(root, ns_env);
+    addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+    xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+    xmlNodePtr setNTP = xmlNewTextChild(body, ns_tds, BAD_CAST "SetNTP", NULL);
+
+    xmlNewTextChild(setNTP, ns_tds, BAD_CAST "FromDHCP", BAD_CAST fromDHCP_buf);
+    if (!onvif_data->ntp_dhcp) {
+        xmlNodePtr ntpManual = xmlNewTextChild(setNTP, ns_tds, BAD_CAST "NTPManual", NULL);
+        xmlNewTextChild(ntpManual, ns_tt, BAD_CAST "Type", BAD_CAST onvif_data->ntp_type);
+		if (strcmp(onvif_data->ntp_type,"IPv4") == 0)
+			xmlNewTextChild(ntpManual, ns_tt, BAD_CAST "IPv4Address", BAD_CAST onvif_data->ntp_addr);
+		else if (strcmp(onvif_data->ntp_type,"IPv6") == 0)
+			xmlNewTextChild(ntpManual, ns_tt, BAD_CAST "IPv6Address", BAD_CAST onvif_data->ntp_addr);
+		else
+			xmlNewTextChild(ntpManual, ns_tt, BAD_CAST "DNSName", BAD_CAST onvif_data->ntp_addr);
+    }
+
+    char cmd[4096] = {0};
+    addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+    xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+    if (reply != NULL) {
+        result = checkForXmlErrorMsg(reply, onvif_data->last_error);
+        xmlFreeDoc(reply);
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
     return result;
 }
 
+int getHostname(struct OnvifData *onvif_data) {
+    int result = 0;
+    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
+    xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+    xmlDocSetRootElement(doc, root);
+    xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+    xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+    xmlSetNs(root, ns_env);
+    addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+    xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+    xmlNewTextChild(body, ns_tds, BAD_CAST "GetHostname", NULL);
+    char cmd[4096] = {0};
+    addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+    xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+    if (reply != NULL) {
+        xmlChar *xpath = BAD_CAST "//s:Body//tds:GetHostnameResponse//tds:HostnameInformation//tt:FromDHCP";
+        xpath = BAD_CAST "//s:Body//tds:GetHostnameResponse//tds:HostnameInformation//tt:Name";
+        getXmlValue(reply, xpath, onvif_data->host_name, 128);
+    } else {
+        result = -1;
+        strcpy(onvif_data->last_error, "No XML reply");
+    }
+    return result;
+}
+
+int setHostname(struct OnvifData *onvif_data) {
+    int result = 0;
+
+    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
+    xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+    xmlDocSetRootElement(doc, root);
+    xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+    xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+    xmlNsPtr ns_tt = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/schema", BAD_CAST "tt");
+    xmlSetNs(root, ns_env);
+    addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+    xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+    if (onvif_data->host_name[0]) {
+        xmlNodePtr setHostname = xmlNewTextChild(body, ns_tds, BAD_CAST "SetHostname", NULL);
+        xmlNewTextChild(setHostname, ns_tds, BAD_CAST "Name", BAD_CAST onvif_data->host_name);
+        /* Do I also need to set FromDHCP to false ? */
+    } else {
+        xmlNodePtr setHostname = xmlNewTextChild(body, ns_tds, BAD_CAST "SetHostnameFromDHCP", NULL);
+        xmlNewTextChild(setHostname, ns_tds, BAD_CAST "FromDHCP", BAD_CAST "true");
+    }
+
+    char cmd[4096] = {0};
+    addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+    xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+    if (reply != NULL) {
+		/* Should check for RebootNeeded=true from setHostnameFronDHCP */
+        result = checkForXmlErrorMsg(reply, onvif_data->last_error);
+        xmlFreeDoc(reply);
+    } else {
+        result = -1;
+        strcpy(onvif_data->last_error, "No XML reply");
+    }
+    return result;
+}
+
+
 int getCapabilities(struct OnvifData *onvif_data) {
     int result = 0;
     xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
@@ -331,7 +479,7 @@ int getCapabilities(struct OnvifData *onvif_data) {
     addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
     xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
     xmlNodePtr capabilities = xmlNewTextChild(body, ns_tds, BAD_CAST "GetCapabilities", NULL);
-    xmlNewTextChild(capabilities, ns_tds, BAD_CAST "Category", "All");
+    xmlNewTextChild(capabilities, ns_tds, BAD_CAST "Category", BAD_CAST "All");
     char cmd[4096] = {0};
 
 
@@ -366,8 +514,7 @@ int getCapabilities(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -385,8 +532,10 @@ int getVideoEncoderConfigurationOptions(struct OnvifData *onvif_data) {
     addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
     xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
     xmlNodePtr getVideoEncoderConfigurationOptions = xmlNewTextChild(body, ns_trt, BAD_CAST "GetVideoEncoderConfigurationOptions", NULL);
-    xmlNewTextChild(getVideoEncoderConfigurationOptions, ns_trt, BAD_CAST "ConfigurationToken", BAD_CAST onvif_data->videoEncoderConfigurationToken);
-    xmlNewTextChild(getVideoEncoderConfigurationOptions, ns_trt, BAD_CAST "ProfileToken", BAD_CAST onvif_data->profileToken);
+    if (onvif_data->videoEncoderConfigurationToken[0])
+        xmlNewTextChild(getVideoEncoderConfigurationOptions, ns_trt, BAD_CAST "ConfigurationToken", BAD_CAST onvif_data->videoEncoderConfigurationToken);
+    if (onvif_data->profileToken[0])
+        xmlNewTextChild(getVideoEncoderConfigurationOptions, ns_trt, BAD_CAST "ProfileToken", BAD_CAST onvif_data->profileToken);
     char cmd[4096] = {0};
     addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->media_service, cmd, 4096);
     xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
@@ -411,10 +560,9 @@ int getVideoEncoderConfigurationOptions(struct OnvifData *onvif_data) {
                     cur = cur->next;
                 }
                 char tmp[128] = {0};
-                if ((strlen(width) + strlen(height)) > 124) {
-                  fprintf(stderr, "xmlNodeListString return buffer overflow %d\n", strlen(width) + strlen(height));
-                }
-                else {
+                if ((strlen((char *)width) + strlen((char *)height)) > 124) {
+                  fprintf(stderr, "xmlNodeListString return buffer overflow %lu\n", strlen((char *)width) + strlen((char *)height));
+                } else {
                   sprintf(tmp, "%s x %s", width, height);
                 }
 
@@ -423,8 +571,7 @@ int getVideoEncoderConfigurationOptions(struct OnvifData *onvif_data) {
                 while (!found_size) {
                     if (strlen(onvif_data->resolutions_buf[size]) == 0) {
                         found_size = true;
-                    }
-                    else {
+                    } else {
                         size++;
                         if (size > 15)
                             found_size = true;
@@ -475,8 +622,7 @@ int getVideoEncoderConfigurationOptions(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -507,14 +653,41 @@ int getVideoEncoderConfiguration(struct OnvifData *onvif_data) {
         xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:UseCount";
         if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
             onvif_data->use_count = atoi(temp_buf);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:GuaranteedFrameRate";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0) {
+        if (strcmp(temp_buf, "true") == 0)
+            onvif_data->guaranteed_frame_rate = true;
+        else
+            onvif_data->guaranteed_frame_rate = false;
+        }
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Encoding";
+        getXmlValue(reply, xpath, onvif_data->encoding, 128);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Resolution//tt:Width";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
+            onvif_data->conf_width = atof(temp_buf);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Resolution//tt:Height";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
+            onvif_data->conf_height = atof(temp_buf);
         xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Quality";
         if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
             onvif_data->quality = atof(temp_buf);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:RateControl//tt:FrameRateLimit";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
+            onvif_data->conf_frame_rate_limit = atoi(temp_buf);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:RateControl//tt:EncodingInterval";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
+            onvif_data->conf_encoding_interval = atoi(temp_buf);
+        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:RateControl//tt:BitrateLimit";
+        if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
+            onvif_data->conf_bitrate_limit = atoi(temp_buf);
         xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:H264//tt:H264Profile";
         getXmlValue(reply, xpath, onvif_data->h264_profile_buf, 128);
         xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Multicast//tt:Address//tt:Type";
         getXmlValue(reply, xpath, onvif_data->multicast_address_type_buf, 128);
-        xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Multicast//tt:Address//tt:IPv4Address";
+		if (strcmp(onvif_data->multicast_address_type_buf,"IPv6") == 0)
+            xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Multicast//tt:Address//tt:IPv6Address";
+		else
+            xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Multicast//tt:Address//tt:IPv4Address";
         getXmlValue(reply, xpath, onvif_data->multicast_address_buf, 128);
         xpath = BAD_CAST "//s:Body//trt:GetVideoEncoderConfigurationResponse//trt:Configuration//tt:Multicast//tt:Port";
         if (getXmlValue(reply, xpath, temp_buf, 128) == 0)
@@ -534,8 +707,7 @@ int getVideoEncoderConfiguration(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -555,6 +727,7 @@ int setVideoEncoderConfiguration(struct OnvifData *onvif_data) {
     char multicast_port_buf[128] = {0};
     char multicast_ttl_buf[128] = {0};
     char autostart_buf[128] = {0};
+    char encoding_interval_buf[128] = {0};
 
     sprintf(frame_rate_buf, "%d", onvif_data->frame_rate);
     sprintf(gov_length_buf, "%d", onvif_data->gov_length);
@@ -569,6 +742,7 @@ int setVideoEncoderConfiguration(struct OnvifData *onvif_data) {
         strcpy(autostart_buf, "true");
     else
         strcpy(autostart_buf, "false");
+    sprintf(encoding_interval_buf, "%d", onvif_data->conf_encoding_interval);
 
     xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
     xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
@@ -584,14 +758,18 @@ int setVideoEncoderConfiguration(struct OnvifData *onvif_data) {
     xmlNewProp(configuration, BAD_CAST "token", BAD_CAST onvif_data->videoEncoderConfigurationToken);
     xmlNewTextChild(configuration, ns_tt, BAD_CAST "Name", BAD_CAST onvif_data->video_encoder_name_buf);
     xmlNewTextChild(configuration, ns_tt, BAD_CAST "UseCount", BAD_CAST use_count_buf);
-    xmlNewTextChild(configuration, ns_tt, BAD_CAST "Encoding", BAD_CAST "H264");
+#ifdef ONVIF19060
+	/* Sad, but not supported until 19.06 release - crashes my older camera */
+    xmlNewTextChild(configuration, ns_tt, BAD_CAST "GuaranteedFrameRate", onvif_data->guaranteed_frame_rate?BAD_CAST "true":BAD_CAST "false");
+#endif
+    xmlNewTextChild(configuration, ns_tt, BAD_CAST "Encoding", onvif_data->encoding[0]?BAD_CAST onvif_data->encoding:BAD_CAST "H264");
     xmlNodePtr resolution = xmlNewTextChild(configuration, ns_tt, BAD_CAST "Resolution", NULL);
     xmlNewTextChild(resolution, ns_tt, BAD_CAST "Width", BAD_CAST width_buf);
     xmlNewTextChild(resolution, ns_tt, BAD_CAST "Height", BAD_CAST height_buf);
     xmlNewTextChild(configuration, ns_tt, BAD_CAST "Quality", BAD_CAST quality_buf);
     xmlNodePtr rateControl = xmlNewTextChild(configuration, ns_tt, BAD_CAST "RateControl", NULL);
     xmlNewTextChild(rateControl, ns_tt, BAD_CAST "FrameRateLimit", BAD_CAST frame_rate_buf);
-    xmlNewTextChild(rateControl, ns_tt, BAD_CAST "EncodingInterval", BAD_CAST "1");
+    xmlNewTextChild(rateControl, ns_tt, BAD_CAST "EncodingInterval", BAD_CAST encoding_interval_buf);
     xmlNewTextChild(rateControl, ns_tt, BAD_CAST "BitrateLimit", BAD_CAST bitrate_buf);
     xmlNodePtr h264 = xmlNewTextChild(configuration, ns_tt, BAD_CAST "H264", NULL);
     xmlNewTextChild(h264, ns_tt, BAD_CAST "GovLength", BAD_CAST gov_length_buf);
@@ -611,8 +789,7 @@ int setVideoEncoderConfiguration(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -635,7 +812,6 @@ int getProfile(struct OnvifData *onvif_data) {
     addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->media_service, cmd, 4096);
     xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
     if (reply != NULL) {
-
         char temp_buf[128];
 
         xmlChar *xpath;
@@ -653,9 +829,8 @@ int getProfile(struct OnvifData *onvif_data) {
         xpath = BAD_CAST "//s:Body//trt:GetProfileResponse//trt:Profile//tt:VideoEncoderConfiguration//tt:RateControl//tt:BitrateLimit";
         if (getXmlValue(reply, xpath, temp_buf, 128) == 0) {
             onvif_data->bitrate = atoi(temp_buf);
-        }
-        else {
-            printf("NO BITRATE FOUND\n");
+        } else {
+            onvif_data->bitrate = 0;
         }
         xpath = BAD_CAST "//s:Body//trt:GetProfileResponse//trt:Profile//tt:VideoEncoderConfiguration//tt:H264//tt:GovLength";
         if (getXmlValue(reply, xpath, temp_buf, 128) == 0) {
@@ -663,14 +838,13 @@ int getProfile(struct OnvifData *onvif_data) {
         }
 
         xpath = BAD_CAST "//s:Body//trt:GetProfileResponse//trt:Profile//tt:VideoEncoderConfiguration";
-		getNodeAttribute(reply, xpath, "token", onvif_data->videoEncoderConfigurationToken, 128);
+        getNodeAttribute(reply, xpath, BAD_CAST "token", onvif_data->videoEncoderConfigurationToken, 128);
         xpath = BAD_CAST "//s:Body//trt:GetProfileResponse//trt:Profile//tt:VideoSourceConfiguration//tt:SourceToken";
-		getXmlValue(reply, xpath, onvif_data->videoSourceConfigurationToken, 128);
+        getXmlValue(reply, xpath, onvif_data->videoSourceConfigurationToken, 128);
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -723,8 +897,7 @@ int getOptions(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-     }
-     else {
+     } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -765,8 +938,7 @@ int getImagingSettings(struct OnvifData *onvif_data) {
 
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -807,8 +979,7 @@ int setImagingSettings(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -842,8 +1013,7 @@ int continuousMove(float x, float y, float z, struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -882,8 +1052,7 @@ int moveStop(int type, struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -909,8 +1078,7 @@ int setPreset(char *arg, struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -936,8 +1104,7 @@ int gotoPreset(char *arg, struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -966,8 +1133,7 @@ int setUser(char *new_password, struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1034,8 +1200,147 @@ int setSystemDateAndTime(struct OnvifData *onvif_data) {
     return result;
 }
 
-int getFirstProfileToken(struct OnvifData *onvif_data) {
+int setSystemDateAndTimeUsingTimezone(struct OnvifData *onvif_data) {
+    int result = 0;
+    time_t rawtime;
+    time(&rawtime);
+	bool special = false;
+    struct tm *UTCTime = localtime(&rawtime);
+    char dst_flag_buf[128];
+    if (UTCTime->tm_isdst == 1)
+        strcpy(dst_flag_buf, "true");
+    else
+        strcpy(dst_flag_buf, "false");
+    if (strcmp(onvif_data->timezone,"UTC0") == 0) {
+        special = true;
+    } else {
+        if (!onvif_data->timezone[0]) {
+#ifndef _WIN32
+            // work out a timezone to use on the camera 
+            int h = -(UTCTime->tm_gmtoff/3600);
+            int m = (UTCTime->tm_gmtoff + 3600 * h)/60;
+            if (m)
+                sprintf(onvif_data->timezone,"%s%d:%02d:00%s",tzname[0],h,m,tzname[1]);
+            else
+                sprintf(onvif_data->timezone,"%s%d%s",tzname[0],h,tzname[1]);
+#else
+            int h = _timezone/3600;
+            int m = (_timezone - 3600 * h)/60;
+            if (m)
+                sprintf(onvif_data->timezone,"%s%d:%02d:00%s",_tzname[0],h,m,_tzname[1]);
+            else
+                sprintf(onvif_data->timezone,"%s%d%s",_tzname[0],h,_tzname[1]);
+#endif
+        }
+        UTCTime = gmtime(&rawtime);
+    }
+    if (!onvif_data->datetimetype)
+        onvif_data->datetimetype = 'M'; // manual 
+    char hour_buf[128];
+    char minute_buf[128];
+    char second_buf[128];
+    char year_buf[128];
+    char month_buf[128];
+    char day_buf[128];
+    sprintf(hour_buf, "%d", UTCTime->tm_hour);
+    sprintf(minute_buf, "%d", UTCTime->tm_min);
+    sprintf(second_buf, "%d", UTCTime->tm_sec);
+    sprintf(year_buf, "%d", UTCTime->tm_year + 1900);
+    sprintf(month_buf, "%d", UTCTime->tm_mon + 1);
+    sprintf(day_buf, "%d", UTCTime->tm_mday);
+
+    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
+    xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+    xmlDocSetRootElement(doc, root);
+    xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+    xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+    xmlNsPtr ns_tt = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/schema", BAD_CAST "tt");
+    xmlSetNs(root, ns_env);
+    addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+    xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+    xmlNodePtr setSystemDateAndTime = xmlNewTextChild(body, ns_tds, BAD_CAST "SetSystemDateAndTime", NULL);
+    xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "DateTimeType", BAD_CAST "Manual");
+    xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "DaylightSavings", BAD_CAST dst_flag_buf);
+    xmlNodePtr timeZone = xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "TimeZone", NULL);
+    xmlNewTextChild(timeZone, ns_tt, BAD_CAST "TZ", BAD_CAST onvif_data->timezone);
+    xmlNodePtr utcDateTime = xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "UTCDateTime", NULL);
+    xmlNodePtr cameraTime = xmlNewTextChild(utcDateTime, ns_tt, BAD_CAST "Time", NULL);
+    xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Hour", BAD_CAST hour_buf);
+    xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Minute", BAD_CAST minute_buf);
+    xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Second", BAD_CAST second_buf);
+    xmlNodePtr cameraDate = xmlNewTextChild(utcDateTime, ns_tt, BAD_CAST "Date", NULL);
+    xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Year", BAD_CAST year_buf);
+    xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Month", BAD_CAST month_buf);
+    xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Day", BAD_CAST day_buf);
+    char cmd[4096] = {0};
+    addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+    xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+    if (reply != NULL) {
+        result = checkForXmlErrorMsg(reply, onvif_data->last_error);
+        xmlFreeDoc(reply);
+        if (result == 0 && onvif_data->datetimetype == 'N') {
+            // switch back to NTP after we have nudged it to correct 
+            time_t newtime;
+            time(&newtime);
+            if (newtime != rawtime) {
+                // save a little effort if we are within a second of the previous check 
+                if (special)
+                    UTCTime = localtime(&newtime);
+                else
+                    UTCTime = gmtime(&newtime);
+                sprintf(hour_buf, "%d", UTCTime->tm_hour);
+                sprintf(minute_buf, "%d", UTCTime->tm_min);
+                sprintf(second_buf, "%d", UTCTime->tm_sec);
+                sprintf(year_buf, "%d", UTCTime->tm_year + 1900);
+                sprintf(month_buf, "%d", UTCTime->tm_mon + 1);
+                sprintf(day_buf, "%d", UTCTime->tm_mday);
+            }
+            doc = xmlNewDoc(BAD_CAST "1.0");
+            xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
+            xmlDocSetRootElement(doc, root);
+            xmlNsPtr ns_env = xmlNewNs(root, BAD_CAST "http://www.w3.org/2003/05/soap-envelope", BAD_CAST "SOAP-ENV");
+            xmlNsPtr ns_tds = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/device/wsdl", BAD_CAST "tds");
+            xmlNsPtr ns_tt = xmlNewNs(root, BAD_CAST "http://www.onvif.org/ver10/schema", BAD_CAST "tt");
+            xmlSetNs(root, ns_env);
+            addUsernameDigestHeader(root, ns_env, onvif_data->username, onvif_data->password, onvif_data->time_offset);
+            xmlNodePtr body = xmlNewTextChild(root, ns_env, BAD_CAST "Body", NULL);
+            xmlNodePtr setSystemDateAndTime = xmlNewTextChild(body, ns_tds, BAD_CAST "SetSystemDateAndTime", NULL);
+            xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "DateTimeType", BAD_CAST "NTP");
+            xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "DaylightSavings", BAD_CAST dst_flag_buf);
+            xmlNodePtr timeZone = xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "TimeZone", NULL);
+            xmlNewTextChild(timeZone, ns_tt, BAD_CAST "TZ", BAD_CAST onvif_data->timezone);
+            // Need to include date/time even though the specs say it should be ignored 
+            xmlNodePtr utcDateTime = xmlNewTextChild(setSystemDateAndTime, ns_tds, BAD_CAST "UTCDateTime", NULL);
+            xmlNodePtr cameraTime = xmlNewTextChild(utcDateTime, ns_tt, BAD_CAST "Time", NULL);
+            xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Hour", BAD_CAST hour_buf);
+            xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Minute", BAD_CAST minute_buf);
+            xmlNewTextChild(cameraTime, ns_tt, BAD_CAST "Second", BAD_CAST second_buf);
+            xmlNodePtr cameraDate = xmlNewTextChild(utcDateTime, ns_tt, BAD_CAST "Date", NULL);
+            xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Year", BAD_CAST year_buf);
+            xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Month", BAD_CAST month_buf);
+            xmlNewTextChild(cameraDate, ns_tt, BAD_CAST "Day", BAD_CAST day_buf);
+            char cmd[4096] = {0};
+            addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->device_service, cmd, 4096);
+            xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
+            if (reply != NULL) {
+                result = checkForXmlErrorMsg(reply, onvif_data->last_error);
+		xmlFreeDoc(reply);
+            } else {
+                result = -1;
+		strcpy(onvif_data->last_error, "No XML reply");
+            }
+        }
+    } else {
+        result = -1;
+        strcpy(onvif_data->last_error, "No XML reply");
+    }
+    return result;
+}
+
+int getProfileToken(struct OnvifData *onvif_data, int profileIndex) {
     int result;
+    onvif_data->profileToken[0] = 0;
+
     xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
     xmlNodePtr root = xmlNewDocNode(doc, NULL, BAD_CAST "Envelope", NULL);
     xmlDocSetRootElement(doc, root);
@@ -1049,11 +1354,10 @@ int getFirstProfileToken(struct OnvifData *onvif_data) {
     addHttpHeader(doc, root, onvif_data->xaddrs, onvif_data->media_service, cmd, 4096);
     xmlDocPtr reply = sendCommandToCamera(cmd, onvif_data->xaddrs);
     if (reply != NULL) {
-        getNodeAttribute(reply, BAD_CAST "//s:Body//trt:GetProfilesResponse//trt:Profiles", "token", onvif_data->profileToken, 128);
+        getNodeAttributen(reply, BAD_CAST "//s:Body//trt:GetProfilesResponse//trt:Profiles", BAD_CAST "token", onvif_data->profileToken, 128, profileIndex);
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1091,14 +1395,28 @@ int getTimeOffset(struct OnvifData *onvif_data) {
         getXmlValue(reply, BAD_CAST "//s:Body//tds:GetSystemDateAndTimeResponse//tds:SystemDateAndTime//tt:UTCDateTime//tt:Date//tt:Day", day_buf, 16);
         getXmlValue(reply, BAD_CAST "//s:Body//tds:GetSystemDateAndTimeResponse//tds:SystemDateAndTime//tt:DaylightSavings", dst_buf, 16);
 
+	onvif_data->dst = false;
         int is_dst = 0;
-        if (strcmp(dst_buf, "true") == 0)
+        if (strcmp(dst_buf, "true") == 0) {
             is_dst = 1;
+	    onvif_data->dst = true;
+	}
+
+        getXmlValue(reply, BAD_CAST "//s:Body//tds:GetSystemDateAndTimeResponse//tds:SystemDateAndTime//tt:TimeZone//tt:TZ", onvif_data->timezone, 128);
+	char dttype[16];
+        getXmlValue(reply, BAD_CAST "//s:Body//tds:GetSystemDateAndTimeResponse//tds:SystemDateAndTime//tt:DateTimeType", dttype, 16);
+	onvif_data->datetimetype = dttype[0]; /* M == Manual, N == NTP */
 
         time_t now = time(NULL);
-        struct tm *utc_here = gmtime(&now);
-        utc_here->tm_isdst = -1;
-        time_t utc_time_here = mktime(utc_here);
+        time_t utc_time_here = now;
+	bool special = false;
+	if (strcmp(onvif_data->timezone,"UTC0") == 0) {
+	    /* special case - camera is running on local time believing it is UTC */
+	    special = true;
+            struct tm *utc_here = gmtime(&now);
+            utc_here->tm_isdst = -1;
+            utc_time_here = mktime(utc_here);
+	}
 
         struct tm *utc_there = localtime(&now);
         utc_there->tm_year = atoi(year_buf) - 1900;
@@ -1108,13 +1426,19 @@ int getTimeOffset(struct OnvifData *onvif_data) {
         utc_there->tm_min = atoi(min_buf);
         utc_there->tm_sec = atoi(sec_buf);
         utc_there->tm_isdst = is_dst;
-        time_t utc_time_there = mktime(utc_there);
-        time_t result = utc_time_there - utc_time_here;
-        onvif_data->time_offset = result;
+	time_t utc_time_there;
+	if (special)
+	    utc_time_there = mktime(utc_there);
+	else
+#ifndef _WIN32
+	    utc_time_there = timegm(utc_there);
+#else
+	    utc_time_there = _mkgmtime(utc_there);
+#endif
+	onvif_data->time_offset = utc_time_there - utc_time_here;
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1146,8 +1470,7 @@ int getStreamUri(struct OnvifData *onvif_data) {
         getXmlValue(reply, BAD_CAST "//s:Body//trt:GetStreamUriResponse//trt:MediaUri//tt:Uri", onvif_data->stream_uri, 1024);
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1172,8 +1495,7 @@ int getDeviceInformation(struct OnvifData *onvif_data) {
         getXmlValue(reply, BAD_CAST "//s:Body//tds:GetDeviceInformationResponse//tds:SerialNumber", onvif_data->serial_number, 128);
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1241,8 +1563,7 @@ int rebootCamera(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1267,8 +1588,7 @@ int hardReset(struct OnvifData *onvif_data) {
     if (reply != NULL) {
         result = checkForXmlErrorMsg(reply, onvif_data->last_error);
         xmlFreeDoc(reply);
-    }
-    else {
+    } else {
         result = -1;
         strcpy(onvif_data->last_error, "No XML reply");
     }
@@ -1426,8 +1746,7 @@ int getXmlValue(xmlDocPtr doc, xmlChar *xpath, char buf[], int buf_length) {
                 xmlXPathFreeObject(result);
                 free(keyword);
                 return -4;
-            }
-            else {
+            } else {
                 for (int i=0; i<buf_length; i++)
                     buf[i] = '\0';
                 strcpy(buf, (char*) keyword);
@@ -1441,7 +1760,7 @@ int getXmlValue(xmlDocPtr doc, xmlChar *xpath, char buf[], int buf_length) {
     return 0;
 }
 
-int getNodeAttribute (xmlDocPtr doc, xmlChar *xpath, xmlChar *attribute, char buf[], int buf_length) {
+int getNodeAttributen (xmlDocPtr doc, xmlChar *xpath, xmlChar *attribute, char buf[], int buf_length, int profileIndex) {
     xmlChar *keyword = NULL;
     xmlXPathContextPtr context = xmlXPathNewContext(doc);
     if (context == NULL) {
@@ -1468,14 +1787,16 @@ int getNodeAttribute (xmlDocPtr doc, xmlChar *xpath, xmlChar *attribute, char bu
     }
 
     if (result) {
-        keyword = xmlGetProp(result->nodesetval->nodeTab[0], attribute);
+        if( profileIndex >= result->nodesetval->nodeNr )
+            return -5;
+
+        keyword = xmlGetProp(result->nodesetval->nodeTab[profileIndex], attribute);
         if (keyword != NULL) {
             if (strlen((char*) keyword) > buf_length-1) {
                 xmlXPathFreeObject(result);
                 free(keyword);
                 return -4;
-            }
-            else {
+            } else {
                 for (int i=0; i<buf_length; i++)
                     buf[i] = '\0';
                 strcpy(buf, (char*) keyword);
@@ -1547,8 +1868,7 @@ xmlDocPtr sendCommandToCamera(char *cmd, char *xaddrs) {
     if (mark == NULL) {
         strcpy(host, tmp2);
         strcpy(port_buf, "80");
-    }
-    else {
+    } else {
         start = mark-tmp2;
         for (j=0; j<start; j++) {
             host[j] = tmp2[j];
@@ -1563,10 +1883,10 @@ xmlDocPtr sendCommandToCamera(char *cmd, char *xaddrs) {
 
     int port = atoi(port_buf);
 
-    #ifdef _WIN32
-        WSADATA wsaData;
-        WSAStartup(MAKEWORD(2,2), &wsaData);
-    #endif
+#ifdef _WIN32
+    WSADATA wsaData;
+    WSAStartup(MAKEWORD(2,2), &wsaData);
+#endif
 
     if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
         return NULL;
@@ -1603,7 +1923,7 @@ xmlDocPtr sendCommandToCamera(char *cmd, char *xaddrs) {
         return NULL;
     char http_header[1024];
     for (i=0; i<xml_start; i++) {
-      http_header[i] = buffer[i];
+        http_header[i] = buffer[i];
     }
     http_header[xml_start] = '\0';
 
@@ -1619,8 +1939,7 @@ xmlDocPtr sendCommandToCamera(char *cmd, char *xaddrs) {
         if (http_header[i] == '\r' && http_header[i+1] == '\n') {
             str_xml_length[i - length_start] = '\0';
             break;
-        }
-        else {
+        } else {
             str_xml_length[i - length_start] = http_header[i];
         }
     }
@@ -1643,16 +1962,21 @@ xmlDocPtr sendCommandToCamera(char *cmd, char *xaddrs) {
     }
     xml_reply[xml_length] = '\0';
 
-    #ifdef _WIN32
-        closesocket(sock);
-        WSACleanup();
-    #else
-        close(sock);
-    #endif
+#ifdef _WIN32
+    closesocket(sock);
+    WSACleanup();
+#else
+    close(sock);
+#endif
 
     xmlDocPtr reply = xmlParseMemory(xml_reply, xml_length);
     char error_msg[1024] = {0};
 
+    /* Dump reply if requested */
+    if (dump_reply) {
+        dumpReply(reply);
+    }
+
     return reply;
 }
 
@@ -1748,11 +2072,11 @@ void addUsernameDigestHeader(xmlNodePtr root, xmlNsPtr ns_env, char *user, char
 }
 
 void getBase64(unsigned char * buffer, int chunk_size, unsigned char * result) {
-    char *c = result;
+    char *c = (char *)result;
     int cnt = 0;
     base64_encodestate s;
     base64_init_encodestate(&s);
-    cnt = base64_encode_block(buffer, chunk_size, c, &s);
+    cnt = base64_encode_block((char *)buffer, chunk_size, c, &s);
     c += cnt;
     cnt = base64_encode_blockend(c, &s);
     c += cnt;
@@ -1768,8 +2092,7 @@ void addHttpHeader(xmlDocPtr doc, xmlNodePtr root, char *xaddrs, char *post_type
     if (size > 8191) {
         fprintf(stderr, "xmlOutputBufferGetSize too big %d\n", size);
         strncat(xml, (char*)xmlOutputBufferGetContent(outputbuffer), 8191);
-    }
-    else {
+    } else {
         strcpy(xml, (char*)xmlOutputBufferGetContent(outputbuffer));
     }
 
@@ -1806,8 +2129,7 @@ void addHttpHeader(xmlDocPtr doc, xmlNodePtr root, char *xaddrs, char *post_type
     if (mark == NULL) {
         strcpy(host, tmp2);
         strcpy(port_buf, "80");
-    }
-    else {
+    } else {
         start = mark-tmp2;
         for (j=0; j<start; j++) {
             host[j] = tmp2[j];
@@ -1916,8 +2238,7 @@ int broadcast(struct OnvifSession *onvif_session) {
         if (onvif_session->len[i] > 0) {
             onvif_session->buf[i][onvif_session->len[i]] = '\0';
             i++;
-        }
-        else {
+        } else {
             looping = 0;
             if (onvif_session->len[i] < 0) {
                 //error
@@ -1925,111 +2246,111 @@ int broadcast(struct OnvifSession *onvif_session) {
         }
     }
 
-    #ifdef _WIN32
-        closesocket(broadcast_socket);
-    #else
-        close(broadcast_socket);
-    #endif
+#ifdef _WIN32
+    closesocket(broadcast_socket);
+#else
+    close(broadcast_socket);
+#endif
 
     return i;
 }
 
 void getIPAddress(char buf[128]) {
-    #ifdef _WIN32
-        PMIB_IPADDRTABLE pIPAddrTable;
-        DWORD dwSize = 0;
-        DWORD dwRetVal = 0;
-        IN_ADDR IPAddr;
-
-        pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof(MIB_IPADDRTABLE));
-        if (pIPAddrTable) {
-            if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
-                free(pIPAddrTable);
-                pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
-            }
-            if (pIPAddrTable == NULL) {
-                return;
-            }
+#ifdef _WIN32
+    PMIB_IPADDRTABLE pIPAddrTable;
+    DWORD dwSize = 0;
+    DWORD dwRetVal = 0;
+    IN_ADDR IPAddr;
+    
+    pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof(MIB_IPADDRTABLE));
+    if (pIPAddrTable) {
+        if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
+            free(pIPAddrTable);
+            pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
         }
-
-        if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) != NO_ERROR) {
+        if (pIPAddrTable == NULL) {
             return;
         }
+    }
 
-        int p = 0;
-        while (p < (int)pIPAddrTable->dwNumEntries) {
-            if (pIPAddrTable->table[p].dwAddr != inet_addr("127.0.0.1") && pIPAddrTable->table[p].dwMask == inet_addr("255.255.255.0")) {
-                IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwAddr;
-                strcpy(buf, inet_ntoa(IPAddr));
-                p = (int)pIPAddrTable->dwNumEntries;
-            }
-            p++;
-        }
+    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) != NO_ERROR) {
+        return;
+    }
 
-        if (pIPAddrTable) {
-            free(pIPAddrTable);
-            pIPAddrTable = NULL;
+    int p = 0;
+    while (p < (int)pIPAddrTable->dwNumEntries) {
+        if (pIPAddrTable->table[p].dwAddr != inet_addr("127.0.0.1") && pIPAddrTable->table[p].dwMask == inet_addr("255.255.255.0")) {
+            IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwAddr;
+            strcpy(buf, inet_ntoa(IPAddr));
+            p = (int)pIPAddrTable->dwNumEntries;
         }
+        p++;
+    }
 
-    #else
-
-        #ifdef __APPLE__
-
-            char *address;
-            struct ifaddrs *interfaces = NULL;
-            struct ifaddrs *temp_addr = NULL;
-            int success = 0;
-            success = getifaddrs(&interfaces);
-            if (success == 0) {
-                temp_addr = interfaces;
-                while (temp_addr != NULL) {
-                    address = inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr);
-                    if (strcmp(address, "127.0.0.1") != 0)
-                        strcpy(buf, address);
-                }
-                temp_addr = temp_addr->ifa_next;
-            }
-            freeifaddrs(interfaces);
+    if (pIPAddrTable) {
+        free(pIPAddrTable);
+        pIPAddrTable = NULL;
+    }
 
-        #else
-            struct ifconf ifc;
-            struct ifreq ifr[10];
-            int sd, ifc_num, addr,mask, i;
+#else
 
-            sd = socket(PF_INET, SOCK_DGRAM, 0);
-            if (sd > 0) {
-                ifc.ifc_len = sizeof(ifr);
-                ifc.ifc_ifcu.ifcu_buf = (caddr_t)ifr;
+#if defined(__APPLE__) || defined(__FreeBSD__)
+
+    char *address;
+    struct ifaddrs *interfaces = NULL;
+    struct ifaddrs *temp_addr = NULL;
+    int success = 0;
+    success = getifaddrs(&interfaces);
+    if (success == 0) {
+        temp_addr = interfaces;
+        while (temp_addr != NULL) {
+            address = inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr);
+            if (strcmp(address, "127.0.0.1") != 0)
+                strcpy(buf, address);
+        }
+        temp_addr = temp_addr->ifa_next;
+    }
+    freeifaddrs(interfaces);
 
-                if (ioctl(sd, SIOCGIFCONF, &ifc) == 0) {
-                    ifc_num = ifc.ifc_len / sizeof(struct ifreq);
+#else
+    struct ifconf ifc;
+    struct ifreq ifr[10];
+    int sd, ifc_num, addr,mask, i;
 
-                for (i = 0; i < ifc_num; ++i) {
-                    if (ifr[i].ifr_addr.sa_family != AF_INET) {
-                        continue;
-                    }
+    sd = socket(PF_INET, SOCK_DGRAM, 0);
+    if (sd > 0) {
+        ifc.ifc_len = sizeof(ifr);
+        ifc.ifc_ifcu.ifcu_buf = (caddr_t)ifr;
 
-                    if (ioctl(sd, SIOCGIFNETMASK, &ifr[i]) == 0) {
-                        mask = ((struct sockaddr_in *)(&ifr[i].ifr_netmask))->sin_addr.s_addr;
-                        char mask_buf[128];
-                            sprintf(mask_buf, "%d.%d.%d.%d", INT_TO_ADDR(mask));
-                            if (strcmp(mask_buf, "255.255.255.0") == 0) {
-                                if (ioctl(sd, SIOCGIFADDR, &ifr[i]) == 0) {
-                                    addr = ((struct sockaddr_in *)(&ifr[i].ifr_addr))->sin_addr.s_addr;
-                                    char addr_buf[128];
-                                    sprintf(addr_buf, "%d.%d.%d.%d", INT_TO_ADDR(addr));
-                                    if (strcmp(addr_buf, "127.0.0.1") != 0) {
-                                        strcpy(buf, addr_buf);
-                                    }
-                                }
+        if (ioctl(sd, SIOCGIFCONF, &ifc) == 0) {
+            ifc_num = ifc.ifc_len / sizeof(struct ifreq);
+
+            for (i = 0; i < ifc_num; ++i) {
+                if (ifr[i].ifr_addr.sa_family != AF_INET) {
+                    continue;
+                }
+
+                if (ioctl(sd, SIOCGIFNETMASK, &ifr[i]) == 0) {
+                    mask = ((struct sockaddr_in *)(&ifr[i].ifr_netmask))->sin_addr.s_addr;
+                    char mask_buf[128];
+                    sprintf(mask_buf, "%d.%d.%d.%d", INT_TO_ADDR(mask));
+                    if (strcmp(mask_buf, "255.255.255.0") == 0) {
+                        if (ioctl(sd, SIOCGIFADDR, &ifr[i]) == 0) {
+                            addr = ((struct sockaddr_in *)(&ifr[i].ifr_addr))->sin_addr.s_addr;
+                            char addr_buf[128];
+                            sprintf(addr_buf, "%d.%d.%d.%d", INT_TO_ADDR(addr));
+                            if (strcmp(addr_buf, "127.0.0.1") != 0) {
+                                strcpy(buf, addr_buf);
                             }
                         }
                     }
                 }
             }
-            close(sd);
-        #endif
-    #endif
+        }
+    }
+    close(sd);
+#endif /* not  __APPLE__ || __FreeBSD__ */
+#endif /* not _WIN32 */
 }
 
 int mask2prefix(char *mask_buf) {
@@ -2042,8 +2363,7 @@ int mask2prefix(char *mask_buf) {
         if (number & 1) {
             step = 1;
             count++;
-        }
-        else {
+        } else {
             if (step) {
                 return -1;
             }
@@ -2059,8 +2379,7 @@ void prefix2mask(int prefix, char mask_buf[128]) {
 
     if (prefix) {
         number = htonl(~((1 << (32-prefix)) - 1));
-    }
-    else {
+    } else {
         number = htonl(0);
     }
 
@@ -2077,52 +2396,52 @@ int setSocketOptions(int socket) {
     int status = 0;
     struct in_addr localInterface;
 
-    #ifdef _WIN32
-        PMIB_IPADDRTABLE pIPAddrTable;
-        DWORD dwSize = 0;
-        DWORD dwRetVal = 0;
-        IN_ADDR IPAddr;
-
-        pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof(MIB_IPADDRTABLE));
-        if (pIPAddrTable) {
-            if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
-                free(pIPAddrTable);
-                pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
-            }
-            if (pIPAddrTable == NULL) {
-                printf("Memory allocation failed for GetIpAddrTable\n");
-                return -1;
-            }
+#ifdef _WIN32
+    PMIB_IPADDRTABLE pIPAddrTable;
+    DWORD dwSize = 0;
+    DWORD dwRetVal = 0;
+    IN_ADDR IPAddr;
+
+    pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof(MIB_IPADDRTABLE));
+    if (pIPAddrTable) {
+        if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
+            free(pIPAddrTable);
+            pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
         }
-
-        if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) != NO_ERROR) {
-            printf("GetIpAddrTable failed with error %d\n", dwRetVal);
+        if (pIPAddrTable == NULL) {
+            printf("Memory allocation failed for GetIpAddrTable\n");
             return -1;
         }
+    }
 
-        int p = 0;
-        while (p < (int)pIPAddrTable->dwNumEntries) {
-            IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwAddr;
-            IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwMask;
-            if (pIPAddrTable->table[p].dwAddr != inet_addr("127.0.0.1") && pIPAddrTable->table[p].dwMask == inet_addr("255.255.255.0")) {
-                localInterface.s_addr = pIPAddrTable->table[p].dwAddr;
-                status = setsockopt(socket, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&localInterface, sizeof(localInterface));
-                if (status < 0)
-                    printf("ip_multicast_if error");
-                p = (int)pIPAddrTable->dwNumEntries;
-            }
-            p++;
-        }
+    if ((dwRetVal = GetIpAddrTable(pIPAddrTable, &dwSize, 0)) != NO_ERROR) {
+        printf("GetIpAddrTable failed with error %d\n", dwRetVal);
+        return -1;
+    }
 
-        if (pIPAddrTable) {
-            free(pIPAddrTable);
-            pIPAddrTable = NULL;
+    int p = 0;
+    while (p < (int)pIPAddrTable->dwNumEntries) {
+        IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwAddr;
+        IPAddr.S_un.S_addr = (u_long)pIPAddrTable->table[p].dwMask;
+        if (pIPAddrTable->table[p].dwAddr != inet_addr("127.0.0.1") && pIPAddrTable->table[p].dwMask == inet_addr("255.255.255.0")) {
+            localInterface.s_addr = pIPAddrTable->table[p].dwAddr;
+            status = setsockopt(socket, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&localInterface, sizeof(localInterface));
+            if (status < 0)
+                printf("ip_multicast_if error");
+            p = (int)pIPAddrTable->dwNumEntries;
         }
+        p++;
+    }
+
+    if (pIPAddrTable) {
+        free(pIPAddrTable);
+        pIPAddrTable = NULL;
+    }
 
-        status = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&broadcast, sizeof(broadcast));
-    #else
-        status = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
-    #endif
+    status = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&broadcast, sizeof(broadcast));
+#else
+    status = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
+#endif
     status = setsockopt(socket, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&loopch, sizeof(loopch));
     return 0;
 }
@@ -2130,48 +2449,48 @@ int setSocketOptions(int socket) {
 
 
 #ifdef __MINGW32__
-    int inet_pton(int af, const char *src, void *dst) {
-        struct sockaddr_storage ss;
-        int size = sizeof(ss);
-        char src_copy[INET6_ADDRSTRLEN+1];
-
-        ZeroMemory(&ss, sizeof(ss));
-        strncpy (src_copy, src, INET6_ADDRSTRLEN+1);
-        src_copy[INET6_ADDRSTRLEN] = 0;
-
-        if (WSAStringToAddress(src_copy, af, NULL, (struct sockaddr *)&ss, &size) == 0) {
-            switch(af) {
-                case AF_INET:
-                    *(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;
-                    return 1;
-                case AF_INET6:
-                    *(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;
-                return 1;
-            }
-        }
-        return 0;
-    }
+int inet_pton(int af, const char *src, void *dst) {
+    struct sockaddr_storage ss;
+    int size = sizeof(ss);
+    char src_copy[INET6_ADDRSTRLEN+1];
 
-    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {
-        struct sockaddr_storage ss;
-        unsigned long s = size;
-
-        ZeroMemory(&ss, sizeof(ss));
-        ss.ss_family = af;
+    ZeroMemory(&ss, sizeof(ss));
+    strncpy (src_copy, src, INET6_ADDRSTRLEN+1);
+    src_copy[INET6_ADDRSTRLEN] = 0;
 
+    if (WSAStringToAddress(src_copy, af, NULL, (struct sockaddr *)&ss, &size) == 0) {
         switch(af) {
-            case AF_INET:
-                ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;
-                break;
-            case AF_INET6:
-                ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;
-                break;
-            default:
-                return NULL;
-        }
+	case AF_INET:
+	    *(struct in_addr *)dst = ((struct sockaddr_in *)&ss)->sin_addr;
+	    return 1;
+	case AF_INET6:
+	    *(struct in6_addr *)dst = ((struct sockaddr_in6 *)&ss)->sin6_addr;
+	    return 1;
+	}
+    }
+    return 0;
+}
 
-        return (WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) == 0)?dst : NULL;
+const char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {
+    struct sockaddr_storage ss;
+    unsigned long s = size;
+
+    ZeroMemory(&ss, sizeof(ss));
+    ss.ss_family = af;
+
+    switch(af) {
+    case AF_INET:
+        ((struct sockaddr_in *)&ss)->sin_addr = *(struct in_addr *)src;
+	break;
+    case AF_INET6:
+        ((struct sockaddr_in6 *)&ss)->sin6_addr = *(struct in6_addr *)src;
+	break;
+    default:
+        return NULL;
     }
+
+    return (WSAAddressToString((struct sockaddr *)&ss, sizeof(ss), NULL, dst, &s) == 0)?dst : NULL;
+}
 #endif
 
 
@@ -2238,8 +2557,7 @@ void extractHost(char *xaddrs, char host[128]) {
     mark = strstr(tmp2, ":");
     if (mark == NULL) {
         strcpy(host, tmp2);
-    }
-    else {
+    } else {
         start = mark-tmp2;
         for (j=0; j<start; j++) {
             host[j] = tmp2[j];
@@ -2262,8 +2580,7 @@ void getScopeField(char *scope, char *field_name, char cleaned[1024]) {
         if (mark != NULL) {
             length = mark - field;
             strncpy(field_contents, field, length);
-        }
-        else {
+        } else {
             strcpy(field_contents, field);
         }
 
@@ -2281,8 +2598,7 @@ void getScopeField(char *scope, char *field_name, char cleaned[1024]) {
                 char *ptr;
                 int result = strtol(middle, &ptr, 16);
                 cleaned[j] = result;
-            }
-            else {
+            } else {
                 cleaned[j] = field_contents[i];
             }
         }
@@ -2293,10 +2609,10 @@ void getScopeField(char *scope, char *field_name, char cleaned[1024]) {
 void getCameraName(int ordinal, struct OnvifSession *onvif_session, struct OnvifData *onvif_data) {
     xmlDocPtr xml_input = xmlParseMemory(onvif_session->buf[ordinal], onvif_session->len[ordinal]);
     for(int i=0; i<1024; i++)
-    onvif_data->camera_name[i] = '\0';
+        onvif_data->camera_name[i] = '\0';
 
     char scopes[8192];
-    getXmlValue(xml_input, "//s:Body//d:ProbeMatches//d:ProbeMatch//d:Scopes", scopes, 8192);
+    getXmlValue(xml_input, BAD_CAST "//s:Body//d:ProbeMatches//d:ProbeMatch//d:Scopes", scopes, 8192);
 
     char temp_mfgr[1024] = {0};
     char temp_hdwr[1024] = {0};
@@ -2359,12 +2675,17 @@ void clearData(struct OnvifData *onvif_data) {
         onvif_data->profileToken[i] = '\0';
         onvif_data->username[i] = '\0';
         onvif_data->password[i] = '\0';
+        onvif_data->encoding[i] = '\0';
+    	onvif_data->timezone[i] = '\0';
+    	onvif_data->ntp_type[i] = '\0';
+    	onvif_data->ntp_addr[i] = '\0';
     }
     for (int i=0; i<1024; i++) {
         onvif_data->xaddrs[i] = '\0';
         onvif_data->device_service[i] = '\0';
         onvif_data->stream_uri[i] = '\0';
         onvif_data->camera_name[i] = '\0';
+        onvif_data->host_name[i] = '\0';
     }
     onvif_data->gov_length_min = 0;
     onvif_data->gov_length_max = 0;
@@ -2398,22 +2719,31 @@ void clearData(struct OnvifData *onvif_data) {
     onvif_data->sharpness = 0;
     onvif_data->time_offset = 0;
     onvif_data->event_listen_port = 0;
+    onvif_data->guaranteed_frame_rate = false;
+    onvif_data->conf_width = 0;
+    onvif_data->conf_height = 0;
+    onvif_data->conf_frame_rate_limit = 0;
+    onvif_data->conf_encoding_interval = 0;
+    onvif_data->conf_bitrate_limit = 0;
+    onvif_data->datetimetype = '\0';
+    onvif_data->dst = false;
+    onvif_data->ntp_dhcp = false;
 }
 
 void initializeSession(struct OnvifSession *onvif_session) {
     getUUID(onvif_session->uuid);
     onvif_session->discovery_msg_id = 1;
     xmlInitParser ();
-    #ifdef _WIN32
-        WSADATA wsaData;
-        WSAStartup(MAKEWORD(2,2), &wsaData);
-    #endif
+#ifdef _WIN32
+    WSADATA wsaData;
+    WSAStartup(MAKEWORD(2,2), &wsaData);
+#endif
 }
 
 void closeSession(struct OnvifSession *onvif_session) {
-    #ifdef _WIN32
-        WSACleanup();
-    #endif
+#ifdef _WIN32
+  WSACleanup();
+#endif
     xmlCleanupParser ();
 }
 
@@ -2425,14 +2755,86 @@ void prepareOnvifData(int ordinal, struct OnvifSession *onvif_session, struct On
     getTimeOffset(onvif_data);
 }
 
-int fillRTSP(struct OnvifData *onvif_data) {
-  int result = 0;
-  result = getCapabilities(onvif_data);
+int fillRTSPn(struct OnvifData *onvif_data, int profileIndex) {
+    int result = 0;
+    result = getCapabilities(onvif_data);
     if (result == 0) {
-        result = getFirstProfileToken(onvif_data);
+        result = getProfileToken(onvif_data, profileIndex);
         if (result == 0) {
             result = getStreamUri(onvif_data);
         }
     }
     return result;
 }
+
+
+void dumpXmlNode (xmlDocPtr doc, xmlNodePtr cur_node, char *prefix) {
+    const char *name;
+    const char *value;
+    char new_prefix[1024];
+    char attr[128];
+    xmlAttrPtr prop;
+
+    /* Traverse the tree */
+    for (; cur_node; cur_node = cur_node->next) {
+        if (cur_node->type == XML_ELEMENT_NODE) {
+            name = (char *)(cur_node->name);
+            value = (const char *)xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1);
+            if (value) {
+                printf("%s%s=%s\n", prefix ? prefix : "", name, value);
+            } else {
+                sprintf(new_prefix, "%s%s.", prefix ? prefix : "", name);
+                for (prop = cur_node->properties; prop; prop = prop->next) {
+                    if (prop->children && prop->children->content) {
+                        printf("%s%s=%s\n", new_prefix, prop->name, prop->children->content);
+                    }
+                }
+            }
+        }
+        dumpXmlNode(doc, cur_node->children, new_prefix);
+    }
+}
+
+/* Dump xml document */
+void dumpReply(xmlDocPtr reply) {
+    if (reply != NULL) {
+        xmlChar *xpath = BAD_CAST "//s:Body/*";
+        xmlXPathObjectPtr body = getNodeSet(reply, xpath);
+        if (body) {
+            xmlNodeSetPtr nodeset = body->nodesetval;
+            for (int i=0; i<nodeset->nodeNr; i++) {
+                xmlNodePtr cur = nodeset->nodeTab[i];
+                /* Skip error return */
+                if (strcmp((char *)cur->name, "Fault") != 0) {
+                    printf("[%s]\n", cur->name);
+                    dumpXmlNode(reply, cur->children, NULL);
+                }
+            }
+        }
+    }
+}
+
+/* Dump all available onvif device configuration */
+void dumpConfigAll (struct OnvifData *onvif_data) {
+    xmlDocPtr reply;
+
+    dump_reply = true;
+
+    getNetworkInterfaces(onvif_data);
+    getNetworkDefaultGateway(onvif_data);
+    getDNS(onvif_data);
+    getCapabilities(onvif_data);
+    getVideoEncoderConfigurationOptions(onvif_data);
+    getVideoEncoderConfiguration(onvif_data);
+    getProfile(onvif_data);
+    getOptions(onvif_data);
+    getImagingSettings(onvif_data);
+    getFirstProfileToken(onvif_data);
+    getTimeOffset(onvif_data);
+    getNTP(onvif_data);
+    getHostname(onvif_data);
+    getStreamUri(onvif_data);
+    getDeviceInformation(onvif_data);
+
+    dump_reply = false;
+}
